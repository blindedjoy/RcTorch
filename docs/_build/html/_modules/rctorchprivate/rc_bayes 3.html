
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>rctorchprivate.rc_bayes &#8212; RcTorch 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for rctorchprivate.rc_bayes</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">fabs</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="c1"># from multiprocessing import Pool as mp_Pool</span>
<span class="c1"># import multiprocessing</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">pl</span>
<span class="kn">from</span> <span class="nn">IPython</span> <span class="kn">import</span> <span class="n">display</span>
<span class="kn">from</span> <span class="nn">.defs</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.rc</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">MaxNLocator</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="c1">#import logging</span>
<span class="kn">import</span> <span class="nn">ray</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="k">def</span> <span class="nf">_check_y</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">tensor_args</span> <span class="o">=</span> <span class="p">{}):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary line.</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg1 : int</span>
<span class="sd">        Description of arg1</span>
<span class="sd">    arg2 : str</span>
<span class="sd">        Description of arg2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Description of return value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
         <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">tensor_args</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">y</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="n">tensor_args</span><span class="p">[</span><span class="s2">&quot;device&quot;</span><span class="p">]:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">tensor_args</span><span class="p">[</span><span class="s2">&quot;device&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">_check_x</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">tensor_args</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">supervised</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary line.</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg1 : int</span>
<span class="sd">        Description of arg1</span>
<span class="sd">    arg2 : str</span>
<span class="sd">        Description of arg2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Description of return value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">supervised</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span> <span class="o">**</span><span class="n">tensor_args</span><span class="p">)</span> <span class="c1">#*y.shape,</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">tensor_args</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span>  <span class="o">**</span><span class="n">tensor_args</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span>


<span class="c1"># ideas from yesterday (trip related)</span>
<span class="c1"># 1. moving average RC</span>
<span class="c1"># 2. Penalize the time the algorithm takes to run</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">TurboState</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary line. This is from BOTorch. The Turbo state is a stopping condition.</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : dtype</span>
<span class="sd">        description</span>
<span class="sd">    batch_size : int</span>
<span class="sd">        description</span>
<span class="sd">    length_min : int</span>
<span class="sd">        description</span>
<span class="sd">    length_max : int</span>
<span class="sd">        description</span>
<span class="sd">    failure_counter : dtype</span>
<span class="sd">        description</span>
<span class="sd">    success_counter : dtype</span>
<span class="sd">        description</span>
<span class="sd">    success_tolerance: dtype</span>
<span class="sd">        description</span>
<span class="sd">    best_value: dtype</span>
<span class="sd">           the best value we have seen so far</span>
<span class="sd">    restart_triggered: dtype</span>
<span class="sd">        has a restart been triggered? If yes BO will terminat</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Description of return value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">length_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">**</span> <span class="mi">7</span>
    <span class="n">length_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.6</span>
    <span class="n">failure_counter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">failure_tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>  <span class="c1"># Note: Post-initialized</span>
    <span class="n">success_counter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">success_tolerance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># Note: The original paper uses 3</span>
    <span class="n">best_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="n">restart_triggered</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failure_tolerance</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span>
            <span class="nb">max</span><span class="p">([</span><span class="mf">5.0</span> <span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="p">])</span> <span class="c1">#/ self.batch_size / self.batch_size</span>
        <span class="p">)</span>

<span class="k">def</span> <span class="nf">get_initial_points</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">n_pts</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary line.</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg1 : int</span>
<span class="sd">        Description of arg1</span>
<span class="sd">    arg2 : str</span>
<span class="sd">        Description of arg2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Description of return value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sobol</span> <span class="o">=</span> <span class="n">SobolEngine</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">scramble</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">X_init</span> <span class="o">=</span> <span class="n">sobol</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_pts</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X_init</span>

<span class="k">def</span> <span class="nf">update_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">Y_next</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary line.</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg1 : int</span>
<span class="sd">        Description of arg1</span>
<span class="sd">    arg2 : str</span>
<span class="sd">        Description of arg2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Description of return value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;Updates the turbo state (checks for stopping condition)</span>
<span class="sd">    Essentially this checks our TURBO stopping condition.</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">        state:  the Turbo state</span>
<span class="sd">        Y_next: the most recent error return by the objective function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">Y_next</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">best_value</span> <span class="o">+</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">fabs</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">best_value</span><span class="p">):</span>
        <span class="n">state</span><span class="o">.</span><span class="n">success_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">state</span><span class="o">.</span><span class="n">failure_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">state</span><span class="o">.</span><span class="n">success_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">state</span><span class="o">.</span><span class="n">failure_counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">success_counter</span> <span class="o">==</span> <span class="n">state</span><span class="o">.</span><span class="n">success_tolerance</span><span class="p">:</span>  <span class="c1"># Expand trust region</span>
        <span class="n">state</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">length_max</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">success_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">state</span><span class="o">.</span><span class="n">failure_counter</span> <span class="o">==</span> <span class="n">state</span><span class="o">.</span><span class="n">failure_tolerance</span><span class="p">:</span>  <span class="c1"># Shrink trust region</span>
        <span class="n">state</span><span class="o">.</span><span class="n">length</span> <span class="o">/=</span> <span class="mf">2.0</span>
        <span class="n">state</span><span class="o">.</span><span class="n">failure_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">state</span><span class="o">.</span><span class="n">best_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">best_value</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">Y_next</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">.</span><span class="n">length_min</span><span class="p">:</span>
        <span class="n">state</span><span class="o">.</span><span class="n">restart_triggered</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">state</span>


<span class="k">def</span> <span class="nf">generate_batch</span><span class="p">(</span>
    <span class="n">state</span><span class="p">,</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">X</span><span class="p">,</span>  
    <span class="n">Y</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">,</span>
    <span class="n">n_candidates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_restarts</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">raw_samples</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
    <span class="n">acqf</span><span class="o">=</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span>  <span class="c1"># &quot;ei&quot; or &quot;ts&quot;,</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="n">device</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate a batch for the Bayesian Optimization</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    state : dtype</span>
<span class="sd">        the TURBO state (a stopping metric)</span>
<span class="sd">    model : dtype</span>
<span class="sd">        the GP (Gaussian Process) BOTorch model</span>
<span class="sd">    X : pytorch tensor</span>
<span class="sd">        points evaluated (a vector of hyper-parameter values fed to the objective function) # Evaluated points on the domain [0, 1]^d in original example, not ours.</span>
<span class="sd">    Y : pytorch tensor</span>
<span class="sd">        Function values</span>
<span class="sd">    n_candidates : </span>
<span class="sd">        Number of candidates for Thompson sampling</span>
<span class="sd">    num_restarts : dtype</span>
<span class="sd">        description</span>
<span class="sd">    raw_samples : dtype</span>
<span class="sd">        describe</span>
<span class="sd">    acqf : </span>
<span class="sd">        acquisition function (thompson sampling is preferred)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X_next : pytorch tensor</span>
<span class="sd">        The next set of normalized hyper-parameter values to try</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">acqf</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="s2">&quot;ei&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n_candidates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_candidates</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">200</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Scale the TR to be proportional to the lengthscales</span>
    <span class="n">x_center</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">Y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="p">:]</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">covar_module</span><span class="o">.</span><span class="n">base_kernel</span><span class="o">.</span><span class="n">lengthscale</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)))</span>
    <span class="n">tr_lb</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">x_center</span> <span class="o">-</span> <span class="n">weights</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">tr_ub</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">x_center</span> <span class="o">+</span> <span class="n">weights</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">acqf</span> <span class="o">==</span> <span class="s2">&quot;ts&quot;</span><span class="p">:</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">drawn</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">drawn</span><span class="p">:</span>

            <span class="n">sobol</span> <span class="o">=</span> <span class="n">SobolEngine</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">scramble</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">pert</span> <span class="o">=</span> <span class="n">sobol</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">n_candidates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">pert</span> <span class="o">=</span> <span class="n">tr_lb</span> <span class="o">+</span> <span class="p">(</span><span class="n">tr_ub</span> <span class="o">-</span> <span class="n">tr_lb</span><span class="p">)</span> <span class="o">*</span> <span class="n">pert</span>

            <span class="c1"># Create a perturbation mask</span>
            <span class="n">prob_perturb</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">20.0</span> <span class="o">/</span> <span class="n">dim</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_candidates</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="o">&lt;=</span> <span class="n">prob_perturb</span>
            <span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">),),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Create candidate points from the perturbations and the mask        </span>
            <span class="n">X_cand</span> <span class="o">=</span> <span class="n">x_center</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">n_candidates</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">X_cand</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pert</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="c1"># Sample on the candidate points</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">thompson_sampling</span> <span class="o">=</span> <span class="n">MaxPosteriorSampling</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>  
                    <span class="n">X_next</span> <span class="o">=</span> <span class="n">thompson_sampling</span><span class="p">(</span><span class="n">X_cand</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
                    <span class="n">drawn</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># thompson_sampling = MaxPosteriorSampling(model=model, replacement=False)</span>
                <span class="c1"># X_next = thompson_sampling(X_cand+torch.rand_like(X_cand)*0.002, num_samples=batch_size)</span>
                <span class="c1"># drawn = True</span>
                <span class="c1"># #assert False, &#39;failed to draw from thompson_sampling&#39;</span>
                <span class="c1"># pass</span>
                <span class="c1"># try:</span>
                <span class="c1">#     ei = qExpectedImprovement(model, Y.max(), maximize=True)</span>
                <span class="c1">#     with torch.no_grad():  </span>
                <span class="c1">#         X_next, acq_value = optimize_acqf(</span>
                <span class="c1">#             ei,</span>
                <span class="c1">#             bounds=torch.stack([tr_lb, tr_ub]),</span>
                <span class="c1">#             q=batch_size,</span>
                <span class="c1">#             num_restarts=num_restarts,</span>
                <span class="c1">#             raw_samples=raw_samples,</span>
                <span class="c1">#         )</span>
                <span class="c1"># except:</span>
                <span class="n">X_next</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">X_cand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        


    <span class="k">elif</span> <span class="n">acqf</span> <span class="o">==</span> <span class="s2">&quot;ei&quot;</span><span class="p">:</span>
        <span class="n">ei</span> <span class="o">=</span> <span class="n">qExpectedImprovement</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">train_Y</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">maximize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">X_next</span><span class="p">,</span> <span class="n">acq_value</span> <span class="o">=</span> <span class="n">optimize_acqf</span><span class="p">(</span>
            <span class="n">ei</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">tr_lb</span><span class="p">,</span> <span class="n">tr_ub</span><span class="p">]),</span>
            <span class="n">q</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">num_restarts</span><span class="o">=</span><span class="n">num_restarts</span><span class="p">,</span>
            <span class="n">raw_samples</span><span class="o">=</span><span class="n">raw_samples</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">X_next</span>

<span class="k">class</span> <span class="nc">SparseBooklet</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;A set of preloaded reservoir weights matching the reservoir seed and approximate sparcity (if applicable)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    book: dict</span>
<span class="sd">        the set of approximate reservoir tensors and associated connectivity thresholds</span>
<span class="sd">    keys:</span>
<span class="sd">        the key to access the dictionary (typically an approximate sparcity threshold)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">book</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse_book</span> <span class="o">=</span> <span class="n">book</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse_keys_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_approx_preRes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connectivity_threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Given a connectivity threshold, the method will return the sparse matrix most closely matching that threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        connectivity_threshold: float</span>
<span class="sd">            #TODO description</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print(&quot;sparse_keys&quot;, self.sparse_keys_, &quot;connectivity_threshold&quot;, connectivity_threshold   )</span>
        <span class="n">key_</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">sparse_keys_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_keys_</span> <span class="o">&gt;</span> <span class="n">connectivity_threshold</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">sparse_book</span><span class="p">[</span><span class="n">key_</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">val</span>

<span class="k">class</span> <span class="nc">GlobalSparseLibrary</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This will approximate the search for the sparcity hyper-parameter, which will dramatically speed up training of the network.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lb: int</span>
<span class="sd">        lower bound (connectivity)</span>
<span class="sd">    ub: int</span>
<span class="sd">        upper bound (connectivity)</span>
<span class="sd">    n_nodes: number of nodes in the reservoir</span>
<span class="sd">    precision: the precision of the approximate sparcity metric</span>
<span class="sd">    flip_the_script: bool</span>
<span class="sd">        completely randomizes which reservoir has been selected.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_nodes</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">flip_the_script</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="n">lb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ub</span> <span class="o">=</span> <span class="n">ub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes_</span> <span class="o">=</span> <span class="n">n_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">library</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">book_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flip_the_script</span> <span class="o">=</span> <span class="n">flip_the_script</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        

    <span class="k">def</span> <span class="nf">addBook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a sparse reservoir set by looping through different different connectivity values and assigining one reservoir weight matrix per connetivity level</span>
<span class="sd">        and storing these for downstream use by RcNetwork</span>
<span class="sd">        We generate the reservoir weights and store them in the sparse library.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_seed: the random seed of the SparseLibrary with which to make the preloaded reservoir matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">book</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes_</span>
        
        <span class="n">random_state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="n">accept</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> 
        <span class="n">reservoir_pre_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span><span class="mi">1</span>

        <span class="s2">&quot;for now we&#39;re going to avoid sparse matrices&quot;</span>
        <span class="k">for</span> <span class="n">connectivity</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">):</span> <span class="c1">#, device = self.device):</span>
            <span class="c1">#book[connectivity] = csc_matrix((accept &lt; connectivity ) * reservoir_pre_weights)</span>
            
            <span class="n">book</span><span class="p">[</span><span class="n">connectivity</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">accept</span> <span class="o">&lt;</span> <span class="n">connectivity</span> <span class="p">)</span> <span class="o">*</span> <span class="n">reservoir_pre_weights</span>
        <span class="n">sparse_keys_</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">book</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="n">random_seed</span><span class="p">]</span> <span class="o">=</span> <span class="n">SparseBooklet</span><span class="p">(</span><span class="n">book</span> <span class="o">=</span> <span class="n">book</span><span class="p">,</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">sparse_keys_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">book_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns book indices&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">book_indices</span>

    <span class="k">def</span> <span class="nf">get_approx_preRes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connectivity_threshold</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This function is for use by RcNetwork to access different sets of reservoir matrices.</span>
<span class="sd">        Given a connectivity threshold we access a reservoir by approximate sparcity / connectivity.</span>
<span class="sd">        But which randomly generated reservoir we select is determined by the index, which is what ESN uses if the one reservoir is nilpotent.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            connectivity threshold: float</span>
<span class="sd">            index: int</span>
<span class="sd">                which preloaded reservoir do we want to load? Each index references a difference Sparse Booklet (ie a different reservoir)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sparse booklet for reading downstream by RcNetwork class</span>
<span class="sd">        (we are returning a set of pre-loaded matrices to speed up optimization of the echo-state network by avoiding </span>
<span class="sd">        repeated tensor generation.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip_the_script</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">book_indices</span><span class="p">))</span>
        <span class="c1">#print(&quot;index&quot;, index, &quot;book indices&quot;, self.book_indices, &quot;self.library&quot;, self.library)</span>
        <span class="n">book</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">library</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">book_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">printc</span><span class="p">(</span><span class="s2">&quot;retrieving book from library&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">book_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]),</span> <span class="s1">&#39;green&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">book</span><span class="o">.</span><span class="n">get_approx_preRes</span><span class="p">(</span><span class="n">connectivity_threshold</span><span class="p">)</span>

<span class="c1">#@ray.remote</span>
<span class="k">class</span> <span class="nc">ReservoirBuildingBlocks</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; An object that allows us to save reservoir components (independent of hyper-parameters) for faster optimization.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        model_type: either random, cyclic or delay line</span>
<span class="sd">        input_weight_type: exponential or uniform</span>
<span class="sd">        random_seed: the random seed to set the reservoir</span>
<span class="sd">        n_nodes: the nodes of the network</span>
<span class="sd">        n_inputs: the number of observers in the case of a block experiment, the size of the output in the case of a pure prediction where teacher forcing is used.</span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">input_weight_type</span><span class="p">,</span> <span class="n">random_seed</span> <span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_inputs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                       <span class="n">Distance_matrix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sparse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reservoir_weight_dist</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1">#print(&quot;INITIALING RESERVOIR&quot;)</span>

        <span class="c1">#initialize attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">random_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensorArgs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;device&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">input_weight_type_</span> <span class="o">=</span> <span class="n">input_weight_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_type_</span> <span class="o">=</span> <span class="n">model_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs_</span> <span class="o">=</span> <span class="n">n_inputs</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes_</span> <span class="o">=</span> <span class="n">n_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes_</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_weight_dist</span> <span class="o">=</span> <span class="n">reservoir_weight_dist</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_ran_res_params</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_sparse_accept_dict</span><span class="p">()</span>
                <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reservoir_weight_dist</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_pre_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">gen</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">reservoir_weight_dist</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
                <span class="n">shape_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">)</span>
                <span class="n">ones_tensor</span><span class="p">,</span> <span class="n">zeros_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape_tuple</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">dev</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape_tuple</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">dev</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mean</span> <span class="o">=</span> <span class="n">ones_tensor</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">zeros_tensor</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_weight_dist</span><span class="si">}</span><span class="s2"> reservoir_weight_distribution not yet implimented&quot;</span>
                

            <span class="n">random_state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">accept</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> 
            


    <span class="k">def</span> <span class="nf">gen_ran_res_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates the matrices required for generating reservoir weights&quot;&quot;&quot;</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accept</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">tensorArgs</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">gen</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_pre_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">tensorArgs</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">gen</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">gen_sparse_accept_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reservoir_seeds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">123</span><span class="p">,</span> <span class="mi">999</span><span class="p">],</span> <span class="n">precision</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        #TODO description</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reservoir_seeds:</span>
<span class="sd">            preloaded reservoirs to generate (random seeds will uniquely create different reservoirs)</span>
<span class="sd">            precision: how precisely do you want to approximate connectivity in log space? </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">printc</span><span class="p">(</span><span class="s2">&quot;GENERATING SPARSE DICT&quot;</span><span class="p">,</span> <span class="s1">&#39;cyan&#39;</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">sparse_dict</span>
        
        <span class="c1">#printc(&quot;Building approximate sparse reservoirs for faster optimization ...&quot;,&#39;fail&#39;)</span>
        <span class="c1">#for connectivity in np.logspace(0, -5, precision):</span>
        <span class="c1">#    sparse_dict[connectivity] = csc_matrix((self.accept &lt; connectivity ) * self.reservoir_pre_weights)</span>
        <span class="c1">#self.sparse_keys_ = np.array(sorted(sparse_dict))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_preloaded_sparse_sets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reservoir_seeds</span><span class="p">)</span>
        <span class="n">sparse_dict</span> <span class="o">=</span> <span class="n">GlobalSparseLibrary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span><span class="p">,</span> <span class="n">n_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">random_seed</span> <span class="ow">in</span> <span class="n">reservoir_seeds</span><span class="p">:</span>
            <span class="n">printc</span><span class="p">(</span><span class="s2">&quot;generated sparse reservoir library for random seed &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">random_seed</span><span class="p">),</span> <span class="s1">&#39;cyan&#39;</span><span class="p">)</span>
            <span class="n">sparse_dict</span><span class="o">.</span><span class="n">addBook</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_approx_preRes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connectivity_threshold</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        You can use the matrix returned instead of...</span>
<span class="sd">        TODO doctstring</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">sparse_dict</span><span class="o">.</span><span class="n">get_approx_preRes</span><span class="p">(</span><span class="n">connectivity_threshold</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">get_approx_preRes_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connectivity_threshold</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        You can use the matrix returned instead of...</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs : dict</span>
<span class="sd">            contains start_index and random_seed. </span>
<span class="sd">                    (+) start index determines where to start the cross-validated sample</span>
<span class="sd">                    (+) random seed defines the reservoir&#39;s random seed.</span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        dict of new training and validation sets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key_</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">sparse_keys_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_keys_</span> <span class="o">&gt;</span> <span class="n">connectivity_threshold</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">val</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sparse_dict</span><span class="p">[</span><span class="n">key_</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">gen_in_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generates the reservoir input weight matrix</span>
<span class="sd">        </span>
<span class="sd">        This method assigns the reservoir input weights for later use downstream by the RcNetwork class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs : None</span>
<span class="sd">        Returns: None</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs_</span>
            <span class="n">in_w_shape_</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;m,n&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

            <span class="c1">#at the moment all input weight matrices use uniform bias.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">gen</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1">#weights</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_weight_type_</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">in_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">),</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">gen</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">in_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_weights</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;in_weights&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="s1">&#39;n_in&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs_</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_weight_type_</span> <span class="o">==</span> <span class="s2">&quot;exponential&quot;</span><span class="p">:</span>
                <span class="n">printc</span><span class="p">(</span><span class="s2">&quot;BUILDING SIGN_&quot;</span><span class="p">,</span> <span class="s1">&#39;fail&#39;</span><span class="p">)</span>
                <span class="n">sign1</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span> <span class="p">(</span><span class="n">in_w_shape_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">in_w_shape_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">sign2</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span> <span class="p">(</span><span class="n">in_w_shape_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">in_w_shape_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">sign_dual</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign1</span><span class="p">,</span> <span class="n">sign2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sign1</span><span class="p">,</span> <span class="n">sign2</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1">#regularization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">feedback_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">tensorArgs</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">gen</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1">#regularization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_z</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">tensorArgs</span><span class="p">,</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">gen</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;RcBayesOpt&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">process_score</span><span class="p">(</span><span class="n">score__</span><span class="p">,</span> <span class="n">upper_error_limit</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary line.</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg1 : int</span>
<span class="sd">        Description of arg1</span>
<span class="sd">    arg2 : str</span>
<span class="sd">        Description of arg2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Description of return value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">score__</span><span class="p">):</span>
        <span class="n">score__</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">upper_error_limit</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">,</span> <span class="n">requires_grad</span>  <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">score__</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">score__</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">upper_error_limit</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">,</span> <span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">score__</span>

<span class="k">def</span> <span class="nf">combine_score</span><span class="p">(</span><span class="n">tr_score</span><span class="p">,</span> <span class="n">val_score</span><span class="p">,</span> <span class="n">tr_score_prop</span><span class="p">,</span> <span class="n">log_score</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary line.</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg1 : int</span>
<span class="sd">        Description of arg1</span>
<span class="sd">    arg2 : str</span>
<span class="sd">        Description of arg2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Description of return value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tr_score</span> <span class="o">=</span> <span class="n">tr_score</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">val_score</span> <span class="o">=</span> <span class="n">val_score</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">log_score</span><span class="p">:</span>
        <span class="n">tr_score</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">tr_score</span><span class="p">)</span>
        <span class="n">val_score</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">val_score</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tr_score</span> <span class="o">*</span> <span class="n">tr_score_prop</span> <span class="o">+</span> <span class="n">val_score</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span> <span class="n">tr_score_prop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">tr_score</span> <span class="o">*</span> <span class="n">tr_score_prop</span> <span class="o">+</span> <span class="n">val_score</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span> <span class="n">tr_score_prop</span><span class="p">))</span>




<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">CUDAA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">CUDAA</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cuda is available&quot;</span><span class="p">)</span>
        <span class="n">n_gpus</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cuda is not available&quot;</span><span class="p">)</span>
        <span class="n">n_gpus</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">CUDAA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">CUDAA</span><span class="p">:</span>
        <span class="n">n_gpus</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_gpus</span> <span class="o">=</span> <span class="mi">0</span>



<span class="nd">@ray</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">num_gpus</span><span class="o">=</span><span class="n">n_gpus</span><span class="p">,</span> <span class="n">max_calls</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">execute_objective</span><span class="p">(</span><span class="n">parallel_arguments</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">X_turbo_spec</span><span class="p">,</span> <span class="n">trust_region_id</span><span class="p">):</span><span class="c1">#arguments):</span>
    <span class="sd">&quot;&quot;&quot; Function at the heart of RCTorch, train a network on multiple rounds of cross-validated train/test info, then return the average error.</span>
<span class="sd">    This method also deals with dispatching mutliple series to the objective function if there are multiple, and aggregates the returned scores</span>
<span class="sd">        by averaging.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        arguments: a list of arguments that have been put into dictionary form for multiprocessing convenience</span>
<span class="sd">        upper_error_limit: brutal error clipping upper bound, &#39;nan&#39; error function returns the maximum upper limit as well to discourage</span>
<span class="sd">                the algorithm from searching in that part of the parameter space.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        tuple of score (float), the prediction and validation sets for plotting (optional), and the job id</span>

<span class="sd">    (we need the job id to resort and relate X and y for BO Opt which have been scrambled by multiprocessing)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#parallel_arguments</span>
    <span class="c1"># device, delcaration_args, backprop_args, cv_args, train_args, test_args</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;device&quot;</span><span class="p">]</span>
    <span class="n">declaration_args</span> <span class="o">=</span> <span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;declaration_args&quot;</span><span class="p">]</span>
    <span class="n">backprop_args</span> <span class="o">=</span> <span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;backprop_args&quot;</span><span class="p">]</span>
    <span class="n">cv_args</span> <span class="o">=</span>  <span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;cv_args&quot;</span><span class="p">]</span>
    <span class="n">log_score</span><span class="p">,</span> <span class="n">tr_score_prop</span> <span class="o">=</span> <span class="n">cv_args</span><span class="p">[</span><span class="s2">&quot;log_score&quot;</span><span class="p">],</span>  <span class="n">cv_args</span><span class="p">[</span><span class="s2">&quot;tr_score_prop&quot;</span><span class="p">]</span>
    
    <span class="c1">#TODO Take the parallelism away from the batches, and give it to the trust_regions.</span>
    <span class="n">total_score</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># print(f&#39;parameters {parameters}&#39;)</span>
    <span class="c1"># sleep(1)</span>

    <span class="c1"># assert False, f&#39;parameters, {parameters}&#39;</span>

    <span class="n">RC</span> <span class="o">=</span> <span class="n">RcNetwork</span><span class="p">(</span><span class="o">**</span><span class="n">declaration_args</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">,</span> <span class="n">id_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">train_args</span> <span class="o">=</span> <span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;train_args&quot;</span><span class="p">]</span>
    <span class="n">test_args</span> <span class="o">=</span> <span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;test_args&quot;</span><span class="p">]</span>
    <span class="n">fit_inputs</span> <span class="o">=</span> <span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;fit_inputs&quot;</span><span class="p">]</span>
    <span class="n">val_inputs</span> <span class="o">=</span> <span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;val_inputs&quot;</span><span class="p">]</span>
    <span class="n">n_cv_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fit_inputs</span><span class="p">)</span>

    <span class="n">ode</span> <span class="o">=</span> <span class="n">train_args</span><span class="p">[</span><span class="s2">&quot;ODE_order&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fit_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fit_inputs</span><span class="p">):</span>

        <span class="n">cv_sample_score</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">val_input</span> <span class="o">=</span> <span class="n">val_inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ode</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">RC</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">fit_input</span><span class="p">,</span> <span class="n">train_score</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">train_args</span><span class="p">)</span>
            <span class="n">train_scores</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">]</span>
            <span class="n">val_scores</span><span class="p">,</span> <span class="n">pred_</span><span class="p">,</span> <span class="n">id_</span> <span class="o">=</span> <span class="n">RC</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="o">**</span><span class="n">val_input</span><span class="p">,</span> <span class="o">**</span><span class="n">test_args</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">train_score</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">train_scores</span><span class="p">):</span>
                
                <span class="n">train_scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_score</span><span class="p">(</span><span class="n">train_score</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">)</span>
                <span class="n">val_score</span> <span class="o">=</span> <span class="n">process_score</span><span class="p">(</span><span class="n">val_scores</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">)</span><span class="c1"># / divis</span>
                <span class="n">round_score</span> <span class="o">=</span> <span class="n">combine_score</span><span class="p">(</span><span class="n">train_score</span><span class="p">,</span> <span class="n">val_score</span><span class="p">,</span> <span class="n">tr_score_prop</span><span class="p">,</span> <span class="n">log_score</span><span class="p">)</span>  
                <span class="n">cv_sample_score</span> <span class="o">+=</span> <span class="n">round_score</span> 
            <span class="n">total_score</span> <span class="o">+=</span> <span class="n">cv_sample_score</span>

            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">RC</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">fit_input</span><span class="p">,</span> <span class="o">**</span><span class="n">train_args</span><span class="p">)</span>
            
            <span class="n">val_score</span><span class="p">,</span> <span class="n">pred_</span><span class="p">,</span> <span class="n">id_</span> <span class="o">=</span> <span class="n">RC</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="o">**</span><span class="n">val_input</span><span class="p">,</span> <span class="o">**</span><span class="n">test_args</span><span class="p">)</span>
            <span class="n">val_score</span> <span class="o">=</span> <span class="n">cv_sample_score</span> <span class="o">=</span> <span class="n">process_score</span><span class="p">(</span><span class="n">val_score</span><span class="p">)</span>
            <span class="n">val_scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">val_score</span><span class="p">)]</span>

            <span class="c1">#for j, ... here build in the capability to take in multiple rounds of data.</span>

        <span class="c1"># if id_ != 0:</span>
        <span class="c1">#     del pred_;</span>

        <span class="n">total_score</span> <span class="o">+=</span> <span class="n">cv_sample_score</span>

    <span class="n">total_score</span> <span class="o">=</span> <span class="n">total_score</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_cv_samples</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_scores</span><span class="p">))</span>
    <span class="c1">#print(f&#39;total score: {total_score}&#39;)</span>
    
    
    <span class="n">common_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;X_turbo_spec&quot;</span> <span class="p">:</span> <span class="n">X_turbo_spec</span><span class="p">,</span> <span class="s2">&quot;trust_region_id&quot;</span> <span class="p">:</span> <span class="n">trust_region_id</span><span class="p">}</span> <span class="c1">#, &quot;job_id&quot; : job_id</span>
    <span class="k">if</span> <span class="n">ode</span><span class="p">:</span>
        <span class="n">best_batch_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">])</span>
        <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;scores&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_score</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;pred&quot;</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ys&quot;</span><span class="p">][</span><span class="n">best_idx</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span> 
                                    <span class="s2">&quot;val_y&quot;</span> <span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ydots&quot;</span><span class="p">][</span><span class="n">best_idx</span><span class="p">],</span> 
                                    <span class="s2">&quot;score&quot;</span> <span class="p">:</span> <span class="n">best_batch_score</span><span class="p">,</span> 
                                    <span class="o">**</span><span class="n">common_args</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_score</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;pred&quot;</span><span class="p">:</span> <span class="n">pred_</span><span class="p">,</span> 
                                    <span class="s2">&quot;val_y&quot;</span> <span class="p">:</span> <span class="n">val_input</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> 
                                    <span class="s2">&quot;score&quot;</span> <span class="p">:</span> <span class="n">val_score</span><span class="p">,</span> 
                                    <span class="o">**</span><span class="n">common_args</span><span class="p">}</span>

        <span class="c1"># return {&quot;scores&quot; : scores, </span>
        <span class="c1">#         &quot;weights&quot;: gd_weights, </span>
        <span class="c1">#         &quot;biases&quot; : gd_biases,</span>
        <span class="c1">#         &quot;ys&quot;     : ys,</span>
        <span class="c1">#         &quot;ydots&quot;  : ydots,</span>
        <span class="c1">#         &quot;losses&quot; : Ls}</span>
    <span class="c1"># else:</span>
    <span class="c1">#     return float(total_score), None, id_</span>

<span class="c1">#@ray.remote( max_calls=1)</span>
<span class="k">def</span> <span class="nf">eval_objective_remote</span><span class="p">(</span><span class="n">parallel_args_id</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot_type</span> <span class="o">=</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>  <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This version of the RC helper function</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------</span>
<span class="sd">        parameters: torch.tensor</span>
<span class="sd">            a torch.tensor of the hyper-paramters drawn from the BO_step at time t</span>

<span class="sd">        plot_type</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameter_lst</span><span class="p">,</span> <span class="n">X_turbo_batch</span><span class="p">,</span> <span class="n">trust_region_ids</span> <span class="o">=</span> <span class="n">parameters</span>
        
        <span class="n">num_processes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameter_lst</span><span class="p">)</span>
        <span class="c1">#job_ids = [id(parameter_lst[i]) for i in range(num_processes)]</span>

        <span class="c1">#What is returned by execute_objective:</span>

        <span class="c1">#     return float(total_score), {&quot;pred&quot;: results[&quot;ys&quot;][best_idx].to(&quot;cpu&quot;), &quot;val_y&quot; : results[&quot;ydots&quot;][best_idx], &quot;score&quot; : best_batch_score, &quot;id&quot; : id_}</span>
        <span class="c1"># else:</span>
        <span class="c1">#     return float(total_score), {&quot;pred&quot;: pred_, &quot;val_y&quot; : val_input[&quot;y&quot;], &quot;score&quot; : val_score, &quot;id&quot; : id_}</span>

        <span class="c1">#parallel_arguments, parameters, X_turbo_spec</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="n">execute_objective</span><span class="o">.</span><span class="n">remote</span><span class="p">(</span><span class="n">parallel_args_id</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">X_turbo_batch</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">trust_region_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parameter_lst</span><span class="p">)])</span>

        <span class="c1">#the old way of sorting orgainizing to avoid problems with parallel job asynch, new method is id internal.</span>
        <span class="c1">#results = sorted(results, key=lambda x: x[1][&quot;trust_region_id&quot;]) </span>
        
        <span class="n">scores</span><span class="p">,</span> <span class="n">result_dicts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">))</span> 

        <span class="n">k</span> <span class="o">=</span> <span class="n">best_score_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>

        <span class="n">X_turbo_specs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">result_dict</span><span class="p">[</span><span class="s2">&quot;X_turbo_spec&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">result_dict</span> <span class="ow">in</span> <span class="n">result_dicts</span><span class="p">])</span>

        <span class="n">trust_region_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">result_dict</span><span class="p">[</span><span class="s2">&quot;trust_region_id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">result_dict</span> <span class="ow">in</span> <span class="n">result_dicts</span><span class="p">]</span>

        <span class="n">batch_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pred&quot;</span> <span class="p">:</span> <span class="n">result_dicts</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;pred&quot;</span><span class="p">],</span> 
                      <span class="s2">&quot;y&quot;</span> <span class="p">:</span> <span class="n">result_dicts</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;val_y&quot;</span><span class="p">],</span> 
                      <span class="s2">&quot;trust_region_ids&quot;</span><span class="p">:</span> <span class="n">trust_region_ids</span><span class="p">,</span> 
                      <span class="s2">&quot;best_score&quot;</span> <span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">scores</span><span class="p">)}</span>
       
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">):</span>
            <span class="c1">#score = score.view(1,1)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">Scores_</span> <span class="o">=</span> <span class="p">[</span><span class="n">score</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Scores_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

        
        <span class="n">Scores_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Scores_</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">,</span> <span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">X_turbo_specs</span><span class="p">,</span> <span class="o">-</span><span class="n">Scores_</span><span class="p">,</span> <span class="n">batch_dict</span> <span class="c1">#{ &quot;pred&quot; : pred, &quot;y&quot;: y, &quot;trust_region_id&quot;: trust_region_id}</span>


        <span class="c1">#float(total_score), {&quot;pred&quot;: pred_, &quot;val_y&quot; : val_input[&quot;y&quot;], &quot;score&quot; : val_score}, id_</span>



<span class="k">def</span> <span class="nf">sech2</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Summary line.</span>

<span class="sd">    Extended description of function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg1 : int</span>
<span class="sd">        Description of arg1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Description of return value</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span>

<span class="k">def</span> <span class="nf">if_split</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">train_stop_index</span><span class="p">,</span> <span class="n">validate_stop_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO doctstring</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">train_tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span> <span class="n">train_stop_index</span><span class="p">]</span>
        <span class="n">validate_tensor</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="n">train_stop_index</span><span class="p">:</span> <span class="n">validate_stop_index</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">train_tensor</span><span class="p">,</span> <span class="n">validate_tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">train_tensor</span><span class="p">,</span> <span class="n">validate_tensor</span>

<div class="viewcode-block" id="RcBayesOpt"><a class="viewcode-back" href="../../Pages/api.html#rctorchprivate.rc_bayes.RcBayesOpt">[docs]</a><span class="k">class</span> <span class="nc">RcBayesOpt</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A cross-validation object that automatically optimizes ESN hyperparameters using Bayesian optimization with</span>
<span class="sd">    Gaussian Process priors.</span>

<span class="sd">    Searches optimal solution within the provided bounds.</span>

<span class="sd">    The most important argument is the :attr:`bounds` argument which defines the search space for the various</span>
<span class="sd">    hyper-parameters. An example of this argument is :</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       bounds_dict = { &quot;connectivity&quot; : (0,1),</span>
<span class="sd">           &quot;spectral_radius&quot; : (0.6, 2),</span>
<span class="sd">           &quot;n_nodes&quot; : (1, 353.1),</span>
<span class="sd">           &quot;log_regularization&quot; : (-3, 3),</span>
<span class="sd">           &quot;leaking_rate&quot; : (0, 1),</span>
<span class="sd">           &quot;input_connectivity&quot; : (0, 1),</span>
<span class="sd">           &quot;feedback_connectivity&quot; : (0, 1),</span>
<span class="sd">           &quot;bias&quot;: (0, 1),</span>
<span class="sd">           }</span>
<span class="sd">    .. note::</span>
<span class="sd">        You can search in log-space for any hyper-parameter by including &#39;log_&#39; in the string. For example,</span>
<span class="sd">        if we instead wanted to search for the connectivity between 0.01 and 0.1 we could modify the connectivity argument in the bounds dict above</span>
<span class="sd">        to &#39;log_connectivity : (-2, -1)&#39;.</span>
<span class="sd">    .. warning::</span>
<span class="sd">        The only acquisition function which is currently implimented is Thompson Sampling.</span>

<span class="sd">    </span>

<span class="sd">        </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bounds : dict</span>
<span class="sd">        A dictionary specifying the bounds for optimization. The key is the parameter name and the value</span>
<span class="sd">        is a tuple with minimum value and maximum value of that parameter. E.g. {&#39;n_nodes&#39;: (100, 200), ...}</span>
<span class="sd">    model : class: {RcNetwork}</span>
<span class="sd">            Model class to optimize</span>
<span class="sd">    subsequence_length : int</span>
<span class="sd">        Number of samples in one cross-validation sample</span>
<span class="sd">    initial_samples : int</span>
<span class="sd">        The number of random samples to explore the  before starting optimization</span>
<span class="sd">    validate_fraction : float</span>
<span class="sd">        The fraction of the data that may be used as a validation set</span>
<span class="sd">    batch_size : int</span>
<span class="sd">        Batch size of samples used by BoTorch</span>
<span class="sd">    cv_samples : int</span>
<span class="sd">        Number of samples of the objective function to evaluate for a given parametrization of the ESN</span>
<span class="sd">    scoring_method : {&#39;mse&#39;, &#39;rmse&#39;, &#39;tanh&#39;, &#39;nmse&#39;, &#39;nrmse&#39;, &#39;log&#39;, &#39;log-tanh&#39;, &#39;tanh-nrmse&#39;}</span>
<span class="sd">        Evaluation metric that is used to guide optimization</span>
<span class="sd">    esn_burn_in : int</span>
<span class="sd">        Number of time steps to discard upon training a single Echo State Network</span>
<span class="sd">    esn_feedback : bool or None</span>
<span class="sd">        Build ESNs with feedback (&#39;teacher forcing&#39;) if available</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Verbosity on or off</span>
<span class="sd">    device : string or torch device                                 #TODO flexible implimentation</span>
<span class="sd">        Torch device (either &#39;cpu&#39; or &#39;cuda&#39;)</span>
<span class="sd">    interactive : bool</span>
<span class="sd">        if true, make interactive python plots. Useful in a jupyter notebook.</span>
<span class="sd">    approximate reservoir: bool</span>
<span class="sd">        if true, builds approximate sparse reservoirs and (ie approximate connectivity not precise). </span>
<span class="sd">        It likely slightly reduces the final result&#39;s score but greatly speeds up the algorithm. #SPARCITY NOT IMPLIMENTED IN RCTORCH</span>
<span class="sd">    input_weight_type : string</span>
<span class="sd">        {&quot;uniform&quot;} is currently implimented. </span>
<span class="sd">        #TODO: exponential and normal weights.</span>
<span class="sd">    activation function: nn.function</span>
<span class="sd">        The activation function used in the reservoir</span>
<span class="sd">    model_type: str</span>
<span class="sd">            #TODO</span>
<span class="sd">        right now it is unclear whether this means reservoir type or model type.</span>
<span class="sd">        likely that is unclear because I haven&#39;t implimented cyclic or exponential here. #TODO impliment uniform and expo weights</span>
<span class="sd">    failure tolerance: int</span>
<span class="sd">        the number of times that the model can fail to improve before length is in increased in turbo algo.</span>
<span class="sd">    success_tolerance: int</span>
<span class="sd">        like the explanation above this needs work.</span>
<span class="sd">    length_min: int</span>
<span class="sd">        The stopping condition. If the turbo_state&#39;s length falls below length_min then the algorithm will terminate.</span>
<span class="sd">    learning_rate: float</span>
<span class="sd">        if backprop is True, then the RC will train with gradient descent. In this case this is that learning rate.</span>
<span class="sd">    success_tolerance:</span>
<span class="sd">        #TODO description</span>
<span class="sd">    failure_tolerance:</span>
<span class="sd">        #TOD description</span>
<span class="sd">    steps_ahead : int or None</span>
<span class="sd">        Number of steps to use in n-step ahead prediction for cross validation. `None` indicates prediction</span>
<span class="sd">        of all values in the validation array.</span>
<span class="sd">    max_iterations : int</span>
<span class="sd">        Maximim number of iterations in optimization</span>
<span class="sd">    log_space : bool</span>
<span class="sd">        Optimize in log space or not (take the logarithm of the objective or not before modeling it in the GP)</span>
<span class="sd">        ####### NOT IMPLIMENTED IN TORCH</span>
<span class="sd">    tanh_alpha : float</span>
<span class="sd">        Alpha coefficient used to scale the tanh error function: alpha * tanh{(1 / alpha) * mse}</span>
<span class="sd">    max_time : float</span>
<span class="sd">        Maximum number of seconds before quitting optimization</span>
<span class="sd">    acquisition_type : {&#39;MPI&#39;, &#39;EI&#39;, &#39;LCB&#39;}</span>
<span class="sd">        The type of acquisition function to use in Bayesian Optimization</span>
<span class="sd">    eps : float</span>
<span class="sd">        The number specifying the maximum amount of change in parameters before considering convergence</span>
<span class="sd">    plot : bool</span>
<span class="sd">        Show convergence plot at end of optimization</span>
<span class="sd">    target_score : float</span>
<span class="sd">        Quit when reaching this target score</span>
<span class="sd">    n_jobs : int</span>
<span class="sd">        Maximum number of concurrent jobs</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">####################</span>

    <span class="c1">#### uncompleted tasks:</span>
    <span class="c1">#1) upgrade to multiple acquisition functions.</span>
    <span class="c1">#self.acquisition_type = acquisition_type</span>
    <span class="c1">######</span>
    <span class="c1">#################### NOT IMPLIMENTED YET IN TORCH version (Hayden Fork)</span>
    <span class="c1">#obs_index = None, target_index = None,  Distance_matrix = None, n_res = 1, </span>
    <span class="c1">#self.obs_index = obs_index</span>
    <span class="c1"># self.target_index = target_index</span>
    <span class="c1">#################### NOT IMPLIMENTED IN TORCH version (came from Reinier)</span>
    <span class="c1">#################### eps, aquisition type and njobs seem like good things to port over.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">subsequence_prop</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>  <span class="n">model</span><span class="o">=</span><span class="n">RcNetwork</span><span class="p">,</span> <span class="n">initial_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="c1">#subsequence_length,</span>
                 <span class="n">validate_fraction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">steps_ahead</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">turbo_batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cv_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">scoring_method</span><span class="o">=</span><span class="s1">&#39;nrmse&#39;</span><span class="p">,</span> <span class="n">esn_burn_in</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feedback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_type</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span> <span class="n">activation_function</span> <span class="o">=</span> <span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span> <span class="c1">#nn.Tanh(), </span>
                 <span class="n">output_activation</span> <span class="o">=</span> <span class="s2">&quot;identity&quot;</span><span class="p">,</span>
                 <span class="n">input_weight_type</span> <span class="o">=</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="n">interactive</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                 <span class="n">approximate_reservoir</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">length_min</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">),</span> 
                 <span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">success_tolerance</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                 <span class="n">windowsOS</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">track_in_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">patience</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span> <span class="n">ODE_order</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">dt</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">log_score</span> <span class="o">=</span>  <span class="kc">False</span><span class="p">,</span> <span class="n">act_f_prime</span> <span class="o">=</span> <span class="n">sech2</span><span class="p">,</span> <span class="n">n_inputs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_outputs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">reservoir_weight_dist</span> <span class="o">=</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="n">feedback_weight_dist</span> <span class="o">=</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span> <span class="n">input_weight_dist</span> <span class="o">=</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
                 <span class="n">solve_sample_prop</span> <span class="o">=</span> <span class="mi">1</span>
                 <span class="p">):</span>
        <span class="c1"># assert isinstance(n_inputs, int), &quot;you must enter n_inputs. This is the number of input time series (int)&quot;</span>
        <span class="c1"># assert isinstance(n_outputs, int), &quot;you must enter n_outputs. This is the number of output time series (int)&quot;</span>
        
        <span class="c1">#self.n_res = n_res</span>

        <span class="c1">#assign attributes to self</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">esn_burn_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">esn_burn_in</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> 

        
        <span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errorz_step</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_parameters</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># if not self.windowsOS:</span>
        <span class="c1">#     try:</span>
        <span class="c1">#         multiprocessing.set_start_method(&#39;spawn&#39;)</span>
        <span class="c1">#     except:</span>
        <span class="c1">#         pass</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">device</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch_device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">cuda_is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">torch_device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">):</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">empty_cache</span><span class="p">()</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FEEDBACK:&quot;</span><span class="p">,</span> <span class="n">feedback</span><span class="p">,</span> <span class="s2">&quot;, device:&quot;</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

        <span class="c1">#self.Distance_matrix = Distance_matrix</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="c1"># Normalize bounds domains and remember transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaled_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_scalings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_intercepts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="s2">&quot;n_nodes&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">:</span>
            <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;You must enter n_nodes as an argument into bounds_dict. ie: &#39;\{ n_nodes: 1000 \}&#39;&quot;</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration_durations</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">def</span> <span class="nf">_check_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1 : int</span>
<span class="sd">            Description of arg1</span>
<span class="sd">        arg2 : str</span>
<span class="sd">            Description of arg2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Description of return value</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">prob</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">log_prob</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">bound_limits</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;connectivity&quot;</span> <span class="p">:</span> <span class="n">prob</span><span class="p">,</span> 
                        <span class="s2">&quot;input_connectivity&quot;</span> <span class="p">:</span> <span class="n">prob</span><span class="p">,</span> 
                        <span class="s2">&quot;feedback_connectivity&quot;</span> <span class="p">:</span> <span class="n">prob</span><span class="p">,</span> 
                        <span class="s2">&quot;leaking_rate&quot;</span> <span class="p">:</span> <span class="n">prob</span><span class="p">,</span>
                        <span class="s2">&quot;n_nodes&quot;</span> <span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                        <span class="s2">&quot;log_connectivity&quot;</span> <span class="p">:</span> <span class="n">log_prob</span><span class="p">,</span>
                        <span class="s2">&quot;log_input_connectivity&quot;</span> <span class="p">:</span> <span class="n">log_prob</span><span class="p">,</span>
                        <span class="s2">&quot;log_feedback_connectivity&quot;</span> <span class="p">:</span> <span class="n">log_prob</span><span class="p">,</span>
                        <span class="s2">&quot;log_leaking_rate&quot;</span> <span class="p">:</span> <span class="n">log_prob</span>
                        <span class="p">}</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">bound_limits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>

                <span class="n">llim</span><span class="p">,</span> <span class="n">ulim</span> <span class="o">=</span> <span class="n">bound_limits</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">llim</span><span class="p">,</span> <span class="n">ulim</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">llim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">llim</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1"> limit is illegal, the bound cannot be lower than </span><span class="si">{</span><span class="n">llim</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">ulim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bounds</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ulim</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s1"> limit is illegal, the bound cannot be greater than </span><span class="si">{</span><span class="n">ulim</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="c1">#time.sleep(0.1)</span>

        

    <span class="k">def</span> <span class="nf">_normalize_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Makes sure all bounds feeded into BoTorch are scaled to the domain [0, 1],</span>
<span class="sd">        to aid interpretation of convergence plots.</span>

<span class="sd">        Scalings are saved in instance parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds : dicts</span>
<span class="sd">            Contains dicts with boundary information</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scaled_bounds, scalings, intercepts : tuple</span>
<span class="sd">            Contains scaled bounds (list of dicts in GPy style), the scaling applied (numpy array)</span>
<span class="sd">            and an intercept (numpy array) to transform values back to their original domain</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaled_bounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">scalings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">intercepts</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">non_fixed_params</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">domain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get any fixed parmeters</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
                <span class="c1"># Take note</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fixed_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># Free parameters</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="c1"># Bookkeeping</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

                <span class="c1"># Get scaling</span>
                <span class="n">lower_bound</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
                <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">upper_bound</span> <span class="o">-</span> <span class="n">lower_bound</span>

                <span class="c1"># Transform to [0, 1] domain</span>
                <span class="c1">#scaled_bound = {&#39;name&#39;: name, &#39;type&#39;: &#39;continuous&#39;, &#39;domain&#39;: (0., 1.)} #torch.adjustment required</span>
                <span class="n">non_fixed_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                
                <span class="c1"># Store</span>
                <span class="c1">#scaled_bounds.append(scaled_bound)</span>
                <span class="n">scalings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">intercepts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Domain bounds not understood&quot;</span><span class="p">)</span>
        
        <span class="n">n_hyperparams</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_fixed_params</span><span class="p">)</span>
        
        <span class="n">scaled_bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_hyperparams</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">),</span> 
                                   <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_hyperparams</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scaled_bounds</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">scalings</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">intercepts</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="c1">#torch.adjustment required</span>

    <span class="k">def</span> <span class="nf">_denormalize_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalized_arguments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Denormalize arguments to feed into model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalized_arguments : numpy array</span>
<span class="sd">            Contains arguments in same order as bounds</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        denormalized_arguments : 1-D numpy array</span>
<span class="sd">            Array with denormalized arguments</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">denormalized_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">normalized_arguments</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_scalings</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_intercepts</span>
        <span class="k">return</span> <span class="n">denormalized_bounds</span>

    <span class="k">def</span> <span class="nf">_construct_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs arguments for ESN input from input array.</span>

<span class="sd">        Does so by denormalizing and adding arguments not involved in optimization,</span>
<span class="sd">        like the random seed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1-D numpy array</span>
<span class="sd">            Array containing normalized parameter values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arguments : dict</span>
<span class="sd">            Arguments that can be fed into an ESN</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># Denormalize free parameters</span>
        <span class="n">denormalized_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denormalize_bounds</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


        <span class="n">arguments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="p">,</span> <span class="n">denormalized_values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>

        

        <span class="c1"># self.log_vars = [&#39;connectivity&#39;, &#39;llambda&#39;, &#39;llambda2&#39;, &#39;enet_strength&#39;,</span>
        <span class="c1">#                  &#39;noise&#39;, &#39;regularization&#39;, &#39;dt&#39;, &#39;gamma_cyclic&#39;, &#39;sigma&#39;,</span>
        <span class="c1">#                  #&#39;input_connectivity&#39;, &#39;feedback_connectivity&#39;</span>
        <span class="c1">#                  ]</span>


        <span class="c1"># Add fixed parameters</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_parameters</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">arguments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># if name in self.log_vars:</span>
            <span class="c1">#     arguments[name] = 10. ** value</span>
            <span class="c1"># else:</span>

        <span class="n">user_var_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arguments</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">log_var_indices</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;log_&#39;</span> <span class="ow">in</span> <span class="n">str_</span> <span class="k">for</span> <span class="n">str_</span> <span class="ow">in</span> <span class="n">user_var_list</span><span class="p">]</span>
        <span class="n">user_variables</span> <span class="o">=</span> <span class="p">[(</span><span class="n">str_</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39;log_&#39;</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">str_</span> <span class="ow">in</span> <span class="n">user_var_list</span><span class="p">]</span>



        <span class="bp">self</span><span class="o">.</span><span class="n">log_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">user_variables</span><span class="p">)[</span><span class="n">log_var_indices</span><span class="p">])</span>

        <span class="c1"># for var in self.log_vars:</span>
        <span class="c1">#     if var in arguments:</span>
        <span class="c1">#         arguments[var] = 10. ** arguments[var]  # Log scale correction</span>
        <span class="c1">#         print(&quot;correcting&quot;, var)</span>


        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_vars</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;log_&#39;</span> <span class="o">+</span> <span class="n">var</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;log_&#39;</span> <span class="o">+</span> <span class="n">var</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;n_nodes&#39;</span> <span class="ow">in</span> <span class="n">arguments</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;n_nodes&#39;</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
                <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;n_nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;n_nodes&#39;</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># Discretize #torch.adjustment required</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;n_nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;n_nodes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">feedback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;feedback&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feedback</span>
        
        <span class="k">for</span> <span class="n">argument</span><span class="p">,</span> <span class="n">val_tensor</span> <span class="ow">in</span> <span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arguments</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">arguments</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">arguments</span>

    <span class="k">def</span> <span class="nf">_validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validates inputted data against errors in shape and common mistakes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : numpy array</span>
<span class="sd">            A y-array to be checked (should be 2-D with series in columns)</span>
<span class="sd">        x : numpy array or None</span>
<span class="sd">            Optional x-array to be checked (should have same number of rows as y)</span>
<span class="sd">        verbose: bool</span>
<span class="sd">            Toggle to flag printed messages about common shape issues</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Throws ValueError when data is not in the correct format.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check dimensions</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y-array is not 2 dimensional, if ODE and you didn&#39;t provide y then x is one dim&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: y-array has more series (columns) than samples (rows). Check if this is correct&quot;</span><span class="p">)</span>

        <span class="c1"># Checks for x</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Check dimensions</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x-array is not 2 dimensional&quot;</span><span class="p">)</span>

            <span class="c1"># Check shape equality</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y-array and x-array have different number of samples (rows)&quot;</span><span class="p">)</span>
    

    <span class="k">def</span> <span class="nf">_objective_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">train_y</span><span class="p">,</span> <span class="n">validate_y</span><span class="p">,</span> <span class="n">train_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validate_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns selected error metric on validation set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : array</span>
<span class="sd">            Parametrization of the Echo State Network, in column vector shape: (n, 1).</span>
<span class="sd">        train_y : array</span>
<span class="sd">            Dependent variable of the training set</span>
<span class="sd">        validate_y : array</span>
<span class="sd">            Dependent variable of the validation set</span>
<span class="sd">        train_x : array or None</span>
<span class="sd">            Independent variable(s) of the training set</span>
<span class="sd">        validate_x : array or None</span>
<span class="sd">            Independent variable(s) of the validation set</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : float</span>
<span class="sd">            Score on provided validation set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_arguments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_bounds</span><span class="p">)</span>

        <span class="c1"># Build network </span>
        <span class="n">esn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">arguments</span><span class="p">,</span> <span class="n">activation_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_function</span><span class="p">,</span>
                <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">model_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span><span class="p">,</span>
                <span class="n">input_weight_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_weight_type</span><span class="p">,</span> <span class="n">already_normalized</span> <span class="o">=</span> <span class="n">already_normalized</span><span class="p">)</span>
                <span class="c1">#random_seed = self.random_seed) Distance_matrix = self.Distance_matrix)</span>
                <span class="c1">#bs_idx = self.obs_index, resp_idx = self.target_index, </span>

        <span class="c1"># Train</span>
        <span class="n">esn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">train_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">train_y</span><span class="p">,</span> <span class="n">burn_in</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">esn_burn_in</span><span class="p">)</span>

        <span class="c1"># Validation score</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">esn</span><span class="o">.</span><span class="n">test2</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">validate_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">validate_y</span><span class="p">,</span> <span class="n">scoring_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scoring_method</span><span class="p">,</span> 
                            <span class="n">steps_ahead</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">steps_ahead</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">score</span>

    <span class="k">def</span> <span class="nf">_define_tr_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Splits training sets (X, y) into train and validate sets, in order to later compute multiple samples of the objective function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs : dict</span>
<span class="sd">            contains start_index and random_seed. </span>
<span class="sd">                    (+) start index determines where to start the cross-validated sample</span>
<span class="sd">                    (+) random seed defines the reservoir&#39;s random seed.</span>
<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        dict of new training and validation sets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">start_index</span><span class="p">,</span> <span class="n">random_seed</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;start_index&quot;</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;random_seed&quot;</span><span class="p">]</span>
        <span class="n">train_stop_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_length</span>
        <span class="n">validate_stop_index</span> <span class="o">=</span> <span class="n">train_stop_index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_length</span>

        <span class="c1"># Get samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
            <span class="n">train_y</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">val_y</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">train_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span> <span class="n">train_stop_index</span><span class="p">]</span>
            <span class="n">val_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">train_stop_index</span><span class="p">:</span> <span class="n">validate_stop_index</span><span class="p">]</span>
            

        <span class="n">train_x</span><span class="p">,</span> <span class="n">val_x</span> <span class="o">=</span> <span class="n">if_split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> 
                                        <span class="n">start_index</span><span class="p">,</span> 
                                        <span class="n">train_stop_index</span><span class="p">,</span>
                                        <span class="n">validate_stop_index</span> <span class="p">)</span>

        <span class="c1">##################### beta arguments are currently silenced ###############</span>

        <span class="c1"># train_beta, val_beta = if_split(self.beta, </span>
        <span class="c1">#                                      start_index, </span>
        <span class="c1">#                                      train_stop_index, </span>
        <span class="c1">#                                      validate_stop_index )</span>

        <span class="c1">##################### beta arguments are currently silenced ###############</span>

        <span class="n">fit_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">train_x</span><span class="p">,</span>
                    <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">train_y</span><span class="p">}</span>
        <span class="c1">#&quot;beta&quot;: train_beta}</span>

        <span class="n">val_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">val_x</span><span class="p">,</span>
                    <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">val_y</span><span class="p">}</span>
        <span class="c1">#&quot;beta&quot;: val_beta}</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">fit_dict</span><span class="p">,</span> <span class="n">val_dict</span><span class="p">)</span>
        
        
    <span class="k">def</span> <span class="nf">_build_unq_dict_lst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst2</span><span class="p">,</span> <span class="n">key1</span> <span class="o">=</span> <span class="s2">&quot;start_index&quot;</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="s2">&quot;random_seed&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1 : int</span>
<span class="sd">            Description of arg1</span>
<span class="sd">        arg2 : str</span>
<span class="sd">            Description of arg2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Description of return value</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;This function builds a list of dictionairies with unique keys.</span>

<span class="sd">        Arguments: TODO</span>
<span class="sd">        TODO doctstring</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dict_lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst1</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst2</span><span class="p">)):</span>
                <span class="n">dictt</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">dictt</span><span class="p">[</span><span class="n">key1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lst1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dictt</span><span class="p">[</span><span class="n">key2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">lst2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">dict_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dictt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dict_lst</span>

    <span class="k">def</span> <span class="nf">_objective_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Splits training set into train and validate sets, and computes multiple samples of the objective function.</span>

<span class="sd">        This method also deals with dispatching multiple series to the objective function if there are multiple,</span>
<span class="sd">        and aggregates the returned scores by averaging.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters : array</span>
<span class="sd">            Parametrization of the Echo State Network</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean_score : 2-D array</span>
<span class="sd">            Column vector with mean score(s), (as was required by GPyOpt)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get data</span>
        <span class="c1">#self.parameters = parameters</span>
        <span class="n">training_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">training_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>

        
        <span class="c1"># Set viable sample range</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
            <span class="n">viable_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">esn_burn_in</span>
            <span class="c1"># Get number of series</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_series</span> <span class="o">=</span> <span class="n">training_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">viable_stop</span> <span class="o">=</span> <span class="n">training_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsequence_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">viable_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Get number of series</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_series</span> <span class="o">=</span> <span class="n">training_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">viable_stop</span> <span class="o">=</span> <span class="n">training_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsequence_length</span>

        <span class="c1"># Get sample lengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_length</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subsequence_length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_fraction</span><span class="p">,</span> <span class="n">requires_grad</span>  <span class="o">=</span> <span class="kc">False</span><span class="p">))</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsequence_length</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_length</span>

        <span class="c1">### TORCH</span>
        <span class="n">start_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span> <span class="o">=</span> <span class="n">viable_start</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">viable_stop</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_samples</span><span class="p">,))</span>
        <span class="n">start_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span> <span class="k">for</span> <span class="n">index_tensor</span> <span class="ow">in</span> <span class="n">start_indices</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random_seeds</span>  <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_res</span><span class="p">,),</span> <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span> <span class="c1">#device = self.device, </span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">random_seeds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">]</span>

        <span class="n">objective_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_unq_dict_lst</span><span class="p">(</span><span class="n">start_indices</span><span class="p">,</span> <span class="n">random_seeds</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_define_tr_val</span><span class="p">(</span><span class="n">objective_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">_my_loss_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">start_loc</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">steps_displated</span> <span class="o">=</span> <span class="mi">500</span><span class="p">):</span><span class="c1">#, pred = pred):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ax</span>

<span class="sd">        pred: ???</span>
<span class="sd">        ????</span>

<span class="sd">        start_loc: ???</span>
<span class="sd">        ????</span>

<span class="sd">        valid: ????</span>
<span class="sd">        ????</span>

<span class="sd">        steps displated: int</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>


<span class="sd">        Arguments: TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pred_</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid</span><span class="p">)),</span> <span class="n">valid</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;train&quot;</span><span class="p">)</span>

        <span class="c1">#ax.plot(valid, color = &quot;green&quot;, label = &quot;test&quot;, alpha = 0.4)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="o">-</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pred_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                         <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">pred_</span><span class="p">[</span><span class="n">i</span><span class="p">,:])],</span><span class="mi">0</span><span class="p">),</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span>
        <span class="c1">#ax.set_xlim(start_loc, 2200)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_train_plot_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pred_</span><span class="p">,</span> <span class="n">validate_y</span><span class="p">,</span> <span class="n">steps_displayed</span><span class="p">,</span> <span class="n">elastic_losses</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">restart_triggered</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If you are running rctorch in a jupyter notebook then this function displays live plots so that you can watch training if </span>
<span class="sd">        self.interactive = True.</span>

<span class="sd">        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pred_: torch.tensor</span>
<span class="sd">            the model&#39;s prediction</span>
<span class="sd">        validate_y: torch.tensor</span>
<span class="sd">            the validation set of the response</span>
<span class="sd">        steps_displayed: int</span>
<span class="sd">            the number of timesteps of pred_ and validate_y to show in the plot</span>
<span class="sd">        elastic_losses:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interactive</span><span class="p">:</span>
            <span class="n">display</span><span class="o">.</span><span class="n">clear_output</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
            
            <span class="n">pred_2plot</span> <span class="o">=</span> <span class="n">pred_</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
                <span class="n">validate_y_2plot</span> <span class="o">=</span> <span class="n">validate_y</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">labels</span> <span class="o">=</span> <span class="s2">&quot;best value&quot;</span><span class="p">,</span> <span class="s2">&quot;all samples&quot;</span>

            <span class="c1"># Plot 1: the training history of the bayesian optimization</span>
            
            <span class="c1">#font_dict = {&quot;prop&quot; : {&quot;size&quot;:14}}</span>
            <span class="n">font_dict</span> <span class="o">=</span> <span class="n">legend_font_dict</span> <span class="o">=</span>  <span class="p">{</span><span class="s2">&quot;prop&quot;</span> <span class="p">:</span> <span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}}</span>
            <span class="n">ticks_font_size</span> <span class="o">=</span> <span class="mi">14</span>

            <span class="n">len_min</span><span class="p">,</span> <span class="n">len_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">length_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">length_max</span>

            <span class="n">plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">labels_</span> <span class="o">=</span> <span class="n">labels</span>
                    <span class="n">plot2_label</span> <span class="o">=</span> <span class="s1">&#39;current length&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels_</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                    <span class="n">plot2_label</span> <span class="o">=</span> <span class="kc">None</span>
                
                <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz_step</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">labels_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">labels_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                

                <span class="c1">#plot 2: the turbo state</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_length_progress</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">log2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">plot2_label</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pct_complete</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">max_evals</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;% complete: </span><span class="si">{</span> <span class="n">pct_complete</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1">, n_evals: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            
            <span class="c1">#self.ax[0].set_title(&quot;log(error) vs Thompson Sampling step&quot;)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;log(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scoring_method</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;BO step&quot;</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="o">**</span><span class="n">font_dict</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="mf">0.95</span><span class="p">)))</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
            
            <span class="n">plot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

            <span class="c1">#self.ax[0].set_ylim(10**-8,1)</span>
            <span class="c1"># self.ax[0].set_xtickslabels(fontsize= ticks_font_size )</span>
            <span class="c1"># self.ax[0].set_ytickslabels(fontsize= ticks_font_size )</span>

            <span class="n">plot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">len_max</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">log2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;max length&#39;</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;TURBO state&quot;</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">len_min</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">log2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;target length&#39;</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="o">**</span><span class="n">legend_font_dict</span><span class="p">)</span>

            <span class="c1">#plot 3 (most recent prediction)</span>
            <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span> <span class="ow">and</span> <span class="n">pred_2plot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pred_2plot</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pred_2plot</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;latest pred&quot;</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Phase space&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
                    <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">validate_y_2plot</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;ground truth&quot;</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pred_2plot</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;RC&quot;</span><span class="p">)</span>
                    
                <span class="k">if</span> <span class="n">pred_2plot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
                        
                        <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">validate_y_2plot</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">),</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="p">)</span>
                    
                    <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pred_2plot</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Val Set Prediction&quot;</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">plot</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">()</span>
            <span class="n">by_label</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">handles</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">by_label</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">by_label</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="n">pl</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="o">**</span><span class="n">legend_font_dict</span><span class="p">)</span>
            <span class="n">pl</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

            <span class="n">display</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">gcf</span><span class="p">())</span>

            <span class="c1">#clear the plot outputt and then re-plot</span>
             

    <span class="c1"># def eval_objective(self, parameters, plot_type = &quot;error&quot;, *args):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     This version of the RC helper function</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     parameters: torch.tensor</span>
    <span class="c1">#         a torch.tensor of the hyper-paramters drawn from the BO_step at time t</span>

    <span class="c1">#     plot_type</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     parameter_lst, trust_region_id = parameters</span>
        
    <span class="c1">#     num_processes = len(parameter_lst)</span>
        
    <span class="c1">#     results = ray.get([execute_objective.remote(self.parallel_args_id, parameter_lst[i], i, id(parameter_lst[i])) for i in range(num_processes)])</span>

    <span class="c1">#     results = sorted(results, key=lambda x: x[2]) </span>
    <span class="c1">#     results = [(result[0], result[1]) for result in results]</span>
    <span class="c1">#     scores, preds = list(zip(*results)) </span>

    <span class="c1">#     assert len(scores) == len(preds), f&#39;len scores {len(scores)} len preds {len(preds)}&#39;</span>

    <span class="c1">#     k = best_score_index = np.argmin(scores)</span>

    <span class="c1">#     #if id_ != 0:</span>

    <span class="c1">#     batch_dict = {&quot;pred&quot; : preds[k][&quot;pred&quot;], &quot;y&quot; : preds[k][&quot;val_y&quot;], &quot;trust_region_id&quot;: trust_region_id, &quot;best_score&quot; : min(scores)}</span>
        

    <span class="c1">#     for i, score in enumerate(scores):</span>
    <span class="c1">#         #score = score.view(1,1)</span>
    <span class="c1">#         if not i:</span>
    <span class="c1">#             Scores_ = [score]</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             Scores_.append(score)</span>

        
    <span class="c1">#     Scores_ = torch.tensor(Scores_, dtype = self.dtype, device = self.device, requires_grad = False).unsqueeze(-1)</span>

    <span class="c1">#     return -Scores_, batch_dict #{ &quot;pred&quot; : pred, &quot;y&quot;: y, &quot;trust_region_id&quot;: trust_region_id}</span>

    
    

    
<div class="viewcode-block" id="RcBayesOpt.optimize"><a class="viewcode-back" href="../../Pages/api.html#rctorchprivate.rc_bayes.RcBayesOpt.optimize">[docs]</a>    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_trust_regions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_evals</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">store_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                       <span class="n">scoring_method</span> <span class="o">=</span> <span class="s2">&quot;mse&quot;</span><span class="p">,</span> <span class="n">criterion</span> <span class="o">=</span> <span class="n">MSELoss</span><span class="p">(),</span>
                       <span class="n">epochs</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>  
                       <span class="n">reparam_f</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ODE_criterion</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">init_conditions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                       <span class="n">force</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">backprop_f</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">backprop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">ode_coefs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">solve</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">rounds</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tr_score_prop</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">eq_system</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                        <span class="n">nonlinear_ode</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">reg_type</span> <span class="o">=</span> <span class="s2">&quot;nl_ham&quot;</span><span class="p">,</span> <span class="n">solve_sample_prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span> <span class="c1">#, beta = None</span>
        <span class="sd">&quot;&quot;&quot;Performs optimization (with cross-validation).</span>

<span class="sd">        Uses Bayesian Optimization with Gaussian Process priors to optimize ESN hyperparameters.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            the :attr:`epochs`, :attr:`backprop_f`, and :attr:`learning_rate` arguments only currently only works with unsupervised training.</span>
<span class="sd">            This is the part of RcTorch which fits ODEs, and should only be used for non-linear equations.</span>

<span class="sd">        .. admonition:: And, by the way...</span>

<span class="sd">            :attr:`ODE_criterion`, :attr:`init_conditions`, :attr:`force`, :attr:`reg_type`, :attr:`eq_system`,</span>
<span class="sd">            :attr:`q`,  :attr:`nonlinear_ode`, :attr:`reparam_f` are also unsupervised arguments which should only be used</span>
<span class="sd">            for solving (unsupervised) differential equations.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : numpy array</span>
<span class="sd">            Column vector with target values (y-values)</span>

<span class="sd">        x : numpy array or None</span>
<span class="sd">            Optional array with input values (x-values)</span>

<span class="sd">        store_path : str or None</span>
<span class="sd">            Optional path where to store best found parameters to disk (in JSON)</span>
<span class="sd">        </span>
<span class="sd">        max_evals : int</span>
<span class="sd">            the maximum number of RcNetworks to train</span>

<span class="sd">        epochs : int</span>
<span class="sd">             backprop training epochs</span>

<span class="sd">        tr_score_prop: float</span>
<span class="sd">            if the network is running unsupervised, this argument will allow the network to score the training set as well.</span>
<span class="sd">            for unsupervised (data based runs) this parameter has no effect.</span>

<span class="sd">        n_trust_regions : int</span>
<span class="sd">            This argument determines the n number of BO runs to run simultaeneoulsy. </span>
<span class="sd">            RcTorch uses the Turbo-1 and Turbo-m algorithms, see `this paper &lt;https://arxiv.org/abs/1910.01739&gt;`_ by Uber AI.</span>
<span class="sd">            n total BO arms are run in parallel, and each performs local bayesian optimization which is faster and more robust</span>
<span class="sd">            than standard global bayesian optimization. </span>

<span class="sd">        q : float</span>
<span class="sd">            a diffeq hp</span>




<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_arguments : dict</span>
<span class="sd">            The best parameters found during optimization</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#assign attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nl</span> <span class="o">=</span> <span class="n">nonlinear_ode</span>
        <span class="c1">#assign attributes to self</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="c1">#check for required arguments:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_trust_regions</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;you must enter n_trust_regions (int)&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_evals</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;you must enter max_evals (int)&quot;</span>

        <span class="c1">#process input data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_score_yet</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dev</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;device&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;requires_grad&quot;</span> <span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
            <span class="c1"># if type(y) == np.ndarray:</span>
            <span class="c1">#     y = torch.tensor(y, device = init_device, requires_grad = False)</span>
            <span class="c1"># if len(y.shape) == 1:</span>
            <span class="c1">#     y = y.view(-1, 1)</span>
            <span class="c1"># if y.device != self.device:</span>
            <span class="c1">#     y = y.to(init_device)</span>
            <span class="c1"># self.y = y.type(self.dtype) </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_check_y</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">tensor_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_check_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">tensor_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">supervised</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_check_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">tensor_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">supervised</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;n_nodes&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;n_nodes&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_weight_dist</span> <span class="o">==</span> <span class="s2">&quot;normal&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices</span> <span class="o">=</span> <span class="n">ReservoirBuildingBlocks</span><span class="p">(</span><span class="n">model_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_type</span><span class="p">,</span> 
                                                              <span class="n">random_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">,</span>
                                                              <span class="n">n_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="s2">&quot;n_nodes&quot;</span><span class="p">],</span>
                                                              <span class="n">input_weight_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_weight_type</span><span class="p">,</span>
                                                              <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                                                              <span class="n">reservoir_weight_dist</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_weight_dist</span><span class="p">,</span>
                                                              <span class="n">n_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices</span><span class="p">)</span>

        <span class="c1"># self.n_trust_regions = n_trust_regions</span>
        <span class="c1"># self.store_path = store_path</span>
        <span class="c1"># self.max_evals = max_evals</span>
        <span class="c1"># self.q = q</span>
        <span class="c1"># self.eq_system = eq_system</span>
        <span class="c1"># self.rounds = rounds</span>
        <span class="c1"># self.tr_score_prop = tr_score_prop</span>
        <span class="c1"># self.solve = solve</span>
        <span class="c1"># self.ode_coefs = ode_coefs</span>
        <span class="c1"># self.epochs = epochs</span>
        <span class="c1"># self.nl = nonlinear_ode</span>
        <span class="c1"># self.scoring_method = scoring_method</span>
        <span class="c1"># self.criterion = criterion</span>
        <span class="c1"># self.epochs = epochs</span>
        <span class="c1"># self.learning_rate = learning_rate</span>
        <span class="c1"># self.init_conditions = init_conditions</span>
        <span class="c1"># self.scale = scale</span>
        <span class="c1"># self.force = force</span>

        


        <span class="bp">self</span><span class="o">.</span><span class="n">log2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>


        <span class="n">font</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;size&#39;</span>   <span class="p">:</span> <span class="mi">18</span><span class="p">}</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;font&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">font</span><span class="p">)</span>

        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multiple_ICs</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_conditions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="c1"># if self.ODE_order:</span>
        <span class="c1">#     if self.n_outputs != len(init_conditions):</span>
        <span class="c1">#         assert False, &quot;n_outputs must match the len of ode_coefs and init_conds&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;driven_pop&quot;</span><span class="p">:</span>
                <span class="n">custom_loss</span> <span class="o">=</span> <span class="n">driven_pop_loss</span>
                <span class="n">force</span> <span class="o">=</span> <span class="n">fforce</span>
            <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;simple_pop&quot;</span><span class="p">:</span>
                <span class="n">custom_loss</span> <span class="o">=</span> <span class="n">driven_pop_loss</span>
                <span class="n">force</span> <span class="o">=</span> <span class="n">no_fforce</span>
            <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;ham&quot;</span><span class="p">:</span>
                <span class="n">custom_loss</span> <span class="o">=</span> <span class="n">ham_loss</span>
            <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;no_reg&quot;</span><span class="p">:</span>
                <span class="n">custom_loss</span> <span class="o">=</span> <span class="n">no_reg_loss</span>
            <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;elastic&quot;</span><span class="p">:</span>
                <span class="n">custom_loss</span> <span class="o">=</span> <span class="n">elastic_loss</span>
            <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;hennon&quot;</span><span class="p">:</span>
                <span class="n">force</span> <span class="o">=</span> <span class="n">no_fforce</span>
                <span class="n">custom_loss</span> <span class="o">=</span> <span class="n">hennon_hailes_loss</span>
            <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;multi_attractor&quot;</span><span class="p">:</span>
                <span class="n">force</span> <span class="o">=</span> <span class="n">no_fforce</span>
                <span class="n">custom_loss</span> <span class="o">=</span> <span class="n">multi_attractor_loss</span>
            <span class="k">elif</span> <span class="n">reg_type</span> <span class="o">==</span> <span class="s2">&quot;dual&quot;</span><span class="p">:</span>
                <span class="n">force</span> <span class="o">=</span> <span class="n">no_fforce</span>
                <span class="n">custom_loss</span> <span class="o">=</span> <span class="n">dual_loss</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ODE_criterion</span> <span class="o">=</span> <span class="n">custom_loss</span>
            <span class="k">if</span> <span class="n">backprop_f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">backprop_f</span> <span class="o">=</span> <span class="n">optimize_last_layer</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">backprop_f</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reparam_f</span> <span class="o">=</span> <span class="n">freparam</span>
        
        
        <span class="c1"># Initialize new random state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices</span><span class="o">.</span><span class="n">n_inputs_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices</span><span class="o">.</span><span class="n">n_inputs_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="c1">#max(y.shape[1], 1) if type(x) == type(None) else x.shape[1]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices</span><span class="o">.</span><span class="n">gen_in_weights</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">()</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">init_device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">windowsOS</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>


        <span class="c1">############### beta arguments currently silenced ###################</span>
        <span class="c1">#beta = torch.tensor(beta) if isinstance(beta, np.ndarray) else beta</span>

        <span class="c1">#self.beta = beta.type(self.dtype) if beta is not None else None</span>
        <span class="c1">############### beta arguments currently silenced ###################</span>

        

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subsequence_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsequence_prop</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subsequence_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsequence_prop</span><span class="p">)</span>

        <span class="c1"># Inform user</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model initialization and exploration run...&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interactive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>


        <span class="n">declaration_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;activation_function&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation_function</span><span class="p">,</span>
                             <span class="s1">&#39;output_activation&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_activation</span><span class="p">,</span>
                            <span class="c1">#&#39;act_f_prime&#39; : self.act_f_prime,</span>
                                 <span class="c1">#&#39;backprop&#39; : self.backprop,</span>
                            
                            <span class="c1">#&#39;n_inputs&#39; : self.n_inputs,</span>
                                 <span class="c1">#&#39;model_type&#39; : self.model_type,</span>
                                 <span class="c1">#&#39;input_weight_type&#39; : self.input_weight_type, </span>
                            <span class="s1">&#39;solve_sample_prop&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_sample_prop</span><span class="p">,</span>
                            <span class="s1">&#39;reservoir_weight_dist&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_weight_dist</span><span class="p">,</span>
                            <span class="s1">&#39;approximate_reservoir&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">approximate_reservoir</span><span class="p">,</span>
                            <span class="s2">&quot;device&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                            <span class="s2">&quot;reservoir&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_matrices_id</span><span class="p">,</span>
                            <span class="s2">&quot;reservoir_weight_dist&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_weight_dist</span><span class="p">,</span>
                            <span class="s2">&quot;input_weight_dist&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_weight_dist</span><span class="p">,</span>
                            <span class="s2">&quot;feedback_weight_dist&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">feedback_weight_dist</span><span class="p">,</span>
                            <span class="p">}</span>
        <span class="c1">#assert False, f&quot;n_outputs {declaration_args[&#39;n_outputs&#39;]}&quot;</span>

        <span class="n">train_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;burn_in&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">esn_burn_in</span><span class="p">,</span> 
                       <span class="s2">&quot;ODE_order&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_order</span><span class="p">,</span>
                       <span class="c1">#&quot;track_in_grad&quot; : self.track_in_grad,</span>
                       <span class="s2">&quot;force&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">,</span>
                       <span class="s2">&quot;reparam_f&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reparam_f</span><span class="p">,</span>
                       <span class="s2">&quot;init_conditions&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conditions</span><span class="p">,</span>
                       <span class="s2">&quot;ode_coefs&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ode_coefs</span><span class="p">,</span>
                       <span class="s2">&quot;q&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span>
                       <span class="s2">&quot;eq_system&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_system</span><span class="p">,</span>
                       <span class="s2">&quot;nl&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nl</span><span class="p">,</span>
                       <span class="s2">&quot;backprop_f&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">backprop_f</span><span class="p">,</span>
                       <span class="s2">&quot;epochs&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">,</span>
                       <span class="s2">&quot;SOLVE&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">,</span> 
                       <span class="s1">&#39;n_outputs&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">,</span>
                      <span class="c1">#&quot;track_in_grad&quot; : False,</span>
                      <span class="s2">&quot;init_conditions&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conditions</span><span class="p">,</span>
                      <span class="c1">#&quot;SCALE&quot; : self.scale,</span>
                      <span class="s2">&quot;reparam_f&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reparam_f</span><span class="p">,</span>
                      <span class="s2">&quot;ODE_criterion&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_criterion</span>
                       <span class="c1">#&quot;multiple_ICs&quot; : self.multiple_ICs</span>
                       <span class="p">}</span>

        <span class="n">backprop_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;backprop_f&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">backprop_f</span><span class="p">,</span>
                         <span class="s2">&quot;epochs&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">}</span>

        <span class="n">test_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;scoring_method&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scoring_method</span><span class="p">,</span>
                     <span class="s2">&quot;reparam&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reparam_f</span><span class="p">,</span>
                     <span class="s2">&quot;ODE_criterion&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ODE_criterion</span><span class="p">}</span>
        <span class="n">cv_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;rounds&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounds</span><span class="p">,</span>
                   <span class="s2">&quot;tr_score_prop&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_score_prop</span><span class="p">,</span>
                   <span class="s2">&quot;log_score&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_score</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parallel_arguments</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;declaration_args&quot;</span><span class="p">:</span> <span class="n">declaration_args</span><span class="p">,</span> <span class="c1">#&quot;RC&quot; : RC,</span>
                                   <span class="s2">&quot;train_args&quot;</span><span class="p">:</span> <span class="n">train_args</span><span class="p">,</span>
                                   <span class="s2">&quot;test_args&quot;</span> <span class="p">:</span> <span class="n">test_args</span><span class="p">,</span>
                                   <span class="s2">&quot;backprop_args&quot;</span> <span class="p">:</span> <span class="n">backprop_args</span><span class="p">,</span>
                                   <span class="s2">&quot;device&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                                   <span class="s2">&quot;cv_args&quot;</span> <span class="p">:</span> <span class="n">cv_args</span>
                              <span class="p">}</span>

        <span class="c1"># if self.n_trust_regions == 1:</span>
        <span class="c1">#     self._errorz, self._errorz_step, self._length_progress = {0 : []}, {0 : []}, {0 : []}</span>
        <span class="c1">#     self._errorz[&quot;all&quot;] = []</span>
        <span class="c1">#     best_hyper_parameters = self._turbo_1()</span>
        <span class="c1"># else:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errorz_step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_progress</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errorz_step</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_progress</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        
        <span class="n">best_hyper_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_turbo_m</span><span class="p">()</span>

        
        <span class="k">return</span> <span class="n">best_hyper_parameters</span> <span class="c1">#X_turbo, Y_turbo, state, best_vals, denormed_ #best_arguments</span></div>

    <span class="k">def</span> <span class="nf">_turbo_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1 : int</span>
<span class="sd">            Description of arg1</span>
<span class="sd">        arg2 : str</span>
<span class="sd">            Description of arg2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Description of return value</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart_turbo_m</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        
        <span class="c1"># self.state = self.states[0] = TurboState(dim, length_min = self.length_min, </span>
        <span class="c1">#                         batch_size=self.batch_size, success_tolerance = self.success_tolerance)</span>
        <span class="n">X_init</span> <span class="o">=</span> <span class="n">get_initial_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_samples</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_turbo_initial_samples</span><span class="p">(</span><span class="n">X_init</span> <span class="o">=</span> <span class="n">X_init</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="p">,</span> <span class="n">turbo_state_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>        
        
        <span class="n">n_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_samples</span>
        
        <span class="c1">#self.count = 0</span>
        <span class="c1"># Run until TuRBO converges</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">restart_triggered</span><span class="p">:</span> 
            
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;count: </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_get_cv_samples</span><span class="p">()</span>

            <span class="c1"># Fit a GP model</span>
            <span class="n">train_Y</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            <span class="n">likelihood</span> <span class="o">=</span> <span class="n">GaussianLikelihood</span><span class="p">(</span><span class="n">noise_constraint</span><span class="o">=</span><span class="n">Interval</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">))</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">SingleTaskGP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">,</span> <span class="n">train_Y</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="n">likelihood</span><span class="p">)</span>
            <span class="n">mll</span> <span class="o">=</span> <span class="n">ExactMarginalLogLikelihood</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">likelihood</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
            <span class="n">fit_gpytorch_model</span><span class="p">(</span><span class="n">mll</span><span class="p">)</span>

            <span class="c1"># Create a batch</span>
            <span class="n">X_next</span> <span class="o">=</span> <span class="n">generate_batch</span><span class="p">(</span>
                <span class="n">state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span>
                <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">,</span>
                <span class="n">Y</span><span class="o">=</span><span class="n">train_Y</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">n_candidates</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">200</span> <span class="o">*</span> <span class="n">dim</span><span class="p">)),</span>
                <span class="n">num_restarts</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">raw_samples</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                <span class="n">acqf</span><span class="o">=</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span>
                <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>
            <span class="n">X_next</span> <span class="o">=</span> <span class="n">X_next</span>

            <span class="c1">#assert 1 ==0, X_next</span>

            <span class="n">objective_input</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_params</span><span class="p">(</span><span class="n">X_next</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">Y_next</span><span class="p">,</span> <span class="n">updates_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_objective</span><span class="p">(</span><span class="n">objective_input</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_updates</span><span class="p">(</span> <span class="n">scores</span> <span class="o">=</span> <span class="n">Y_next</span><span class="p">,</span> <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">updates_dict</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>

            <span class="c1"># print(&#39;Y_next&#39;, Y_next)</span>
            <span class="c1"># print(&quot;self.state&quot;, self.state)</span>
            <span class="c1"># Update state </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">update_state</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">Y_next</span><span class="o">=</span><span class="n">Y_next</span><span class="p">)</span>

            <span class="c1"># Append data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">,</span> <span class="n">X_next</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="p">,</span> <span class="n">Y_next</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Print current status</span>
            <span class="c1"># print( </span>
            <span class="c1">#     f&quot;{len(self.X_turbo)}) Best score: {max(Y_next).item():.4f},  TR length: {self.state.length:.2e}&quot; + </span>
            <span class="c1">#     f&quot; length {self.state.length}&quot;# Best value:.item() {state.best_value:.2e},</span>
            <span class="c1"># )</span>
            
            <span class="c1"># print( </span>
            <span class="c1">#     f&quot;TR length: {self.state.length:.2e},&quot; +  f&quot; min length {self.state.length_min:.2e}&quot;</span>
            <span class="c1">#     # + Best value:.item() {state.best_value:.2e},</span>
            <span class="c1"># )</span>

            

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz_step</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s2">&quot;err len: </span><span class="si">{}</span><span class="s2">, err step: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz_step</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">display</span><span class="o">.</span><span class="n">clear_output</span><span class="p">()</span>

        <span class="c1">#update_state       </span>
        <span class="c1">#display.clear_output(wait=True) </span>
        <span class="c1">#display.display(pl.gcf())</span>
                    
        <span class="c1"># Save to disk if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">store_path</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">best_arguments</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="n">best_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="p">)]</span>
        
        <span class="n">denormed_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denormalize_bounds</span><span class="p">(</span><span class="n">best_vals</span><span class="p">)</span>

        <span class="c1">#best_vals = X_turbo[torch.argmax(Y_turbo)]</span>

        <span class="c1">#####Bad temporary code to change it back into a dictionary</span>
        <span class="n">denormed_free_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="p">,</span> <span class="n">denormed_</span><span class="p">))</span>
        <span class="n">denormed_free_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">denormed_free_parameters</span><span class="p">])</span>

        <span class="n">best_hyper_parameters</span> <span class="o">=</span> <span class="n">denormed_free_parameters</span>
        <span class="k">for</span> <span class="n">fixed_parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_parameters</span><span class="p">:</span>
            <span class="n">best_hyper_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="n">fixed_parameter</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">fixed_parameter</span><span class="p">],</span> <span class="o">**</span><span class="n">best_hyper_parameters</span> <span class="p">}</span>

        <span class="c1">#log_vars = [&#39;connectivity&#39;, &#39;llambda&#39;, &#39;llambda2&#39;, &#39;noise&#39;, &#39;regularization&#39;, &#39;dt&#39;]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">best_hyper_parameters</span><span class="p">:</span>
                <span class="n">best_hyper_parameters</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">best_hyper_parameters</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> 


                
        <span class="c1"># Return best parameters</span>
        <span class="k">return</span> <span class="n">best_hyper_parameters</span>

    <span class="k">def</span> <span class="nf">_turbo_split_initial_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_inits</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">turbo_id_override</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;This function splits and prepares the initial samples in order to get initialization done.&quot;&quot;&quot;</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">n_jobs</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="n">X_inits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_clean_batches</span> <span class="o">=</span> <span class="n">nrow</span> <span class="o">//</span> <span class="n">batch_size</span>
        <span class="n">final_batch_size</span> <span class="o">=</span> <span class="n">nrow</span><span class="o">-</span><span class="n">n_clean_batches</span><span class="o">*</span><span class="n">n_jobs</span>

        <span class="n">initial_batches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">turbo_iter</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">turbo_iter</span> <span class="o">+=</span> <span class="p">[</span><span class="n">batch_size</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_clean_batches</span>

        <span class="k">if</span> <span class="n">final_batch_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">turbo_iter</span> <span class="o">+=</span> <span class="p">[</span><span class="n">final_batch_size</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">turbo_id</span><span class="p">,</span> <span class="n">X_init</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X_inits</span><span class="p">):</span>

            <span class="c1">#if there is just one that we want to update, ie we are doing a restart:</span>
            <span class="k">if</span> <span class="n">turbo_id_override</span><span class="p">:</span>
                <span class="n">turbo_id</span> <span class="o">=</span> <span class="n">turbo_id_override</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clean_batches</span><span class="p">):</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_init</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">batch_size</span><span class="p">:</span>
                        <span class="n">X_batch</span> <span class="o">=</span> <span class="n">X_init</span><span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">batch_size</span><span class="p">)</span> <span class="p">:</span> <span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">batch_size</span><span class="p">),</span> <span class="p">:</span> <span class="p">]</span>
                        <span class="n">initial_batches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_params</span><span class="p">(</span><span class="n">X_batch</span><span class="p">),</span> <span class="n">X_batch</span><span class="p">,</span> <span class="p">[</span><span class="n">turbo_id</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_batch</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">final_batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>

                        <span class="n">X_batch</span> <span class="o">=</span> <span class="n">X_init</span><span class="p">[</span> <span class="p">(</span><span class="n">nrow</span> <span class="o">-</span> <span class="n">final_batch_size</span><span class="p">)</span> <span class="p">:,</span> <span class="p">:</span> <span class="p">]</span>
                        <span class="n">initial_batches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_params</span><span class="p">(</span><span class="n">X_batch</span><span class="p">),</span> <span class="n">X_batch</span><span class="p">,</span> <span class="p">[</span><span class="n">turbo_id</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_batch</span><span class="p">)))</span>
            <span class="c1"># else:</span>
            <span class="c1">#     initial_batches.append((self._convert_params(X_init), X_init,  [turbo_id] *  len(X_init)))</span>

        <span class="k">return</span> <span class="n">initial_batches</span><span class="p">,</span> <span class="n">turbo_iter</span>


    <span class="k">def</span> <span class="nf">_execute_initial_parallel_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">turbo_state_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1 : int</span>
<span class="sd">            Description of arg1</span>
<span class="sd">        arg2 : str</span>
<span class="sd">            Description of arg2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Description of return value</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#get the dimensions of the free parameters</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="p">)</span>

        <span class="c1">#initlalize the turbo state for this trust region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">turbo_state_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span> <span class="o">=</span> <span class="n">TurboState</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> 
                                                         <span class="n">length_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_min</span><span class="p">,</span> 
                                                         <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> 
                                                         <span class="n">success_tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">success_tolerance</span><span class="p">)</span>

        <span class="c1">#get the initial randomly sampled points</span>
        <span class="n">X_init</span> <span class="o">=</span> <span class="n">get_initial_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_samples</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1">#get the training and validation sets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_cv_samples</span><span class="p">()</span>


        <span class="n">objective_inputs</span><span class="p">,</span> <span class="n">turbo_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_turbo_split_initial_samples</span><span class="p">([</span><span class="n">X_init</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">turbo_id_override</span> <span class="o">=</span> <span class="n">turbo_state_id</span><span class="p">)</span>

        
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">objective_input</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">objective_inputs</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">result_i</span> <span class="o">=</span> <span class="n">eval_objective_remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_args_id</span><span class="p">,</span> <span class="n">objective_input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="c1">#ray.wait()</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_i</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_samples</span>

        <span class="n">X_nexts</span><span class="p">,</span> <span class="n">Y_nexts</span><span class="p">,</span> <span class="n">batch_dicts</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>
        <span class="n">X_nexts</span><span class="p">,</span> <span class="n">Y_nexts</span><span class="p">,</span> <span class="n">batch_dicts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_nexts</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">Y_nexts</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">batch_dicts</span><span class="p">)</span>

        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_updates</span><span class="p">(</span><span class="n">scores</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_idx_parallel</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">X_next</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X_nexts</span><span class="p">):</span>
            <span class="n">Y_next</span> <span class="o">=</span> <span class="n">Y_nexts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_turbo</span><span class="p">(</span><span class="n">X_next</span> <span class="o">=</span> <span class="n">X_next</span><span class="p">,</span> <span class="n">Y_next</span> <span class="o">=</span> <span class="n">Y_next</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_initial_parallel_batches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1 : int</span>
<span class="sd">            Description of arg1</span>
<span class="sd">        arg2 : str</span>
<span class="sd">            Description of arg2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Description of return value</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">turbo_state_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">turbo_state_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span> <span class="o">=</span> <span class="n">TurboState</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> 
                                                             <span class="n">length_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length_min</span><span class="p">,</span> 
                                                             <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> 
                                                             <span class="n">success_tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">success_tolerance</span><span class="p">)</span>

        <span class="n">X_inits</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_initial_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled_bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_samples</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_get_cv_samples</span><span class="p">()</span>

        <span class="n">objective_inputs</span><span class="p">,</span> <span class="n">turbo_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_turbo_split_initial_samples</span><span class="p">(</span><span class="n">X_inits</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">objective_input</span> <span class="ow">in</span> <span class="n">objective_inputs</span><span class="p">:</span>
            <span class="n">result_i</span> <span class="o">=</span> <span class="n">eval_objective_remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_args_id</span><span class="p">,</span> <span class="n">objective_input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_i</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_samples</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span>

        <span class="n">X_nexts</span><span class="p">,</span> <span class="n">Y_nexts</span><span class="p">,</span> <span class="n">batch_dicts</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>
        <span class="n">X_nexts</span><span class="p">,</span> <span class="n">Y_nexts</span><span class="p">,</span> <span class="n">batch_dicts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_nexts</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">Y_nexts</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">batch_dicts</span><span class="p">)</span>

        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_updates</span><span class="p">(</span><span class="n">scores</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">)]</span>

        <span class="c1">#self._update_idx_parallel(results)</span>


        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">batch_dict</span><span class="p">[</span><span class="s2">&quot;trust_region_ids&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">batch_dict</span> <span class="ow">in</span> <span class="n">batch_dicts</span><span class="p">]</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">id_set</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">+=</span> <span class="n">id_set</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">,</span> <span class="n">idxs</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">X_next</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X_nexts</span><span class="p">):</span>
            <span class="n">Y_next</span> <span class="o">=</span> <span class="n">Y_nexts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_turbo</span><span class="p">(</span><span class="n">X_next</span> <span class="o">=</span> <span class="n">X_next</span><span class="p">,</span> <span class="n">Y_next</span> <span class="o">=</span> <span class="n">Y_next</span><span class="p">)</span>
        

    <span class="c1"># def _initial_updates():</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Summary line.</span>

    <span class="c1">#     Extended description of function.</span>

    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     arg1 : int</span>
    <span class="c1">#         Description of arg1</span>
    <span class="c1">#     arg2 : str</span>
    <span class="c1">#         Description of arg2</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     int</span>
    <span class="c1">#         Description of return value</span>

    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     self.states[turbo_state_id] = state = TurboState(dim, </span>
    <span class="c1">#                         length_min = self.length_min, </span>
    <span class="c1">#                         batch_size=self.batch_size, </span>
    <span class="c1">#                         success_tolerance = self.success_tolerance)</span>
    <span class="c1">#     pass</span>

    <span class="c1"># def _turbo_initial_samples_m(self, X_init, dim, turbo_states):</span>
        
    <span class="c1">#     for turbo_state_id in range(turbo_states):</span>
    <span class="c1">#         self.states[turbo_state_id] = state = TurboState(dim, </span>
    <span class="c1">#                             length_min = self.length_min, </span>
    <span class="c1">#                             batch_size=self.batch_size, </span>
    <span class="c1">#                             success_tolerance = self.success_tolerance)</span>

    <span class="c1">#         if len(X_init) &gt; self.batch_size:</span>
    <span class="c1">#             nrow = X_init.shape[0]</span>
    <span class="c1">#             clean_batches = nrow // self.batch_size</span>
                
    <span class="c1">#             final_batch_size = nrow-clean_batches*self.batch_size</span>
    <span class="c1">#             for i in range(clean_batches):</span>
    <span class="c1">#                 self._get_cv_samples()</span>
    <span class="c1">#                 X_batch = X_init[ (i*self.batch_size) : ((i+1)*self.batch_size), : ]</span>
    <span class="c1">#                 objective_input = (self._convert_params(X_batch), turbo_state_id)</span>
    <span class="c1">#                 Y_batch, updates_dict = self.eval_objective(objective_input) </span>
    <span class="c1">#                 self._updates(Y_batch, updates_dict)</span>
    <span class="c1">#                 self.X_turbo = torch.vstack((self.X_turbo, X_batch))</span>
    <span class="c1">#                 self.Y_turbo = torch.vstack((self.Y_turbo, Y_batch))</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 self._get_cv_samples()</span>
    <span class="c1">#                 # remainder = nrow - final_batch_size</span>
    <span class="c1">#                 # print(&quot;clean batches:&quot;, clean_batches, &quot;, nrow: &quot;, nrow)</span>
    <span class="c1">#                 # print(&quot;remainder&quot;, remainder)</span>
    <span class="c1">#                 if final_batch_size == 0:</span>

    <span class="c1">#                     pass</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     X_batch = X_init[ (nrow - final_batch_size) :, : ]</span>
    <span class="c1">#                     objective_input = (self._convert_params(X_batch), turbo_state_id)</span>
    <span class="c1">#                     Y_batch, updates_dict = self.eval_objective( objective_input) </span>
    <span class="c1">#                     self._updates(Y_batch, updates_dict)</span>

    <span class="c1">#                     self.X_turbo = torch.vstack((self.X_turbo, X_batch))</span>
    <span class="c1">#                     self.Y_turbo = torch.vstack((self.Y_turbo, Y_batch))</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             #Y_init = self.eval_objective( (X_init, turbo_state_id))</span>
    <span class="c1">#             self._get_cv_samples()</span>
    <span class="c1">#             objective_input = (self._convert_params(X_init), turbo_state_id)</span>
    <span class="c1">#             Y_init, updates_dict = self.eval_objective(objective_input) </span>
    <span class="c1">#             self._updates(Y_init, updates_dict)</span>

    <span class="c1">#             self.X_turbo = torch.vstack((self.X_turbo, X_init))</span>
    <span class="c1">#             self.Y_turbo = torch.vstack((self.Y_turbo, Y_init))</span>

    <span class="c1">#         self._idx = torch.vstack((self._idx, turbo_state_id * torch.ones((self.initial_samples, 1), dtype=torch.int32)))</span>
    <span class="c1">#         self.n_evals += self.initial_samples</span>

    <span class="c1">#     #append the errorz to errorz_step</span>
    <span class="c1">#     #self._errorz_step[turbo_state_id] += [max(self._errorz[turbo_state_id])] * self.initial_samples #n_init</span>

    <span class="c1">#     return state</span>

    <span class="k">def</span> <span class="nf">_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">batch_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1 : int</span>
<span class="sd">            Description of arg1</span>
<span class="sd">        arg2 : str</span>
<span class="sd">            Description of arg2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Description of return value</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_score_yet</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_score_yet</span> <span class="o">=</span> <span class="n">batch_dict</span>
        <span class="k">elif</span> <span class="n">batch_dict</span><span class="p">[</span><span class="s2">&quot;best_score&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_score_yet</span><span class="p">[</span><span class="s2">&quot;best_score&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_score_yet</span> <span class="o">=</span> <span class="n">batch_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>   

        <span class="n">trust_region_ids</span> <span class="o">=</span> <span class="n">batch_dict</span><span class="p">[</span><span class="s2">&quot;trust_region_ids&quot;</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">):</span>
            <span class="n">trust_region_id</span> <span class="o">=</span> <span class="n">trust_region_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">trust_region_id</span><span class="p">]</span>
            <span class="n">score__</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_score</span><span class="p">:</span>
                <span class="n">score__</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">score__</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="n">trust_region_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_length_progress</span><span class="p">[</span><span class="n">trust_region_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_errorz_step</span><span class="p">[</span><span class="n">trust_region_id</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="n">trust_region_id</span><span class="p">])]</span><span class="c1">#* len(scores) #+= [min(self._errorz[trust_region_id])] </span>

    <span class="k">def</span> <span class="nf">_update_idx_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1 : int</span>
<span class="sd">            Description of arg1</span>
<span class="sd">        arg2 : str</span>
<span class="sd">            Description of arg2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Description of return value</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: this function is retarded, rewrite.</span>
        <span class="c1">#assert False, results</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
            <span class="n">num_points</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="n">idx_spec</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;trust_region_ids&quot;</span><span class="p">]</span><span class="c1">#</span>
            <span class="n">idxs</span> <span class="o">+=</span> <span class="n">idx_spec</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1">#assert False, results[0][0] </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">,</span> <span class="n">idxs</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 

    <span class="k">def</span> <span class="nf">_get_cv_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO doctstring</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cv_samples</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_objective_sampler</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_samples</span><span class="p">)]</span>

        <span class="n">fit_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">val_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cv_sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv_samples</span><span class="p">):</span>
            <span class="n">cv_sample_score</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">fit_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_sample</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">val_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_sample</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;fit_inputs&quot;</span><span class="p">]</span><span class="o">=</span> <span class="n">fit_inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parallel_arguments</span><span class="p">[</span><span class="s2">&quot;val_inputs&quot;</span><span class="p">]</span><span class="o">=</span> <span class="n">val_inputs</span>

        <span class="c1"># self.parallel_arguments[&quot;fit_inputs&quot;] = fit</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parallel_args_id</span> <span class="o">=</span> <span class="n">ray</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_arguments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1 : int</span>
<span class="sd">            Description of arg1</span>
<span class="sd">        arg2 : str</span>
<span class="sd">            Description of arg2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Description of return value</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_arguments</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>  <span class="nb">range</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

    <span class="k">def</span> <span class="nf">_combine_new_turbo_batches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sorted_lst</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">turbo_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summary line.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sorted_lst : list</span>
<span class="sd">            a sorted list ...</span>
<span class="sd">        n_jobs : int</span>
<span class="sd">            The number of jobs to run</span>
<span class="sd">        turbo_iter : dtype</span>
<span class="sd">            Desc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a list:</span>
<span class="sd">            list(zip(hps, new_batches, new_turbo_ids))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev_index</span> <span class="o">=</span><span class="mi">0</span>
        <span class="n">new_batches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_turbo_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">turbo_iter</span><span class="p">):</span>
            <span class="n">sub_list</span> <span class="o">=</span> <span class="n">sorted_lst</span><span class="p">[</span><span class="n">prev_index</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="n">prev_index</span><span class="p">]</span>
            <span class="n">X_batch_lst</span><span class="p">,</span> <span class="n">turbo_ids</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sub_list</span><span class="p">)</span>
            <span class="n">X_batch_lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_batch_lst</span><span class="p">)</span>
            <span class="n">prev_index</span> <span class="o">+=</span> <span class="n">index</span>

            <span class="n">X_batch_spec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">X_batch_lst</span><span class="p">)</span>
            <span class="n">hps_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_params</span><span class="p">(</span><span class="n">X_batch_spec</span><span class="p">)</span>

            <span class="n">new_turbo_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">turbo_ids</span><span class="p">)</span>
            <span class="n">new_batches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_batch_spec</span><span class="p">)</span>
            <span class="n">hps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hps_spec</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">hps</span><span class="p">,</span> <span class="n">new_batches</span><span class="p">,</span> <span class="n">new_turbo_ids</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_update_turbo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_next</span><span class="p">,</span> <span class="n">Y_next</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the turbo state by concatenating the most recent BO round results to Y_next</span>
<span class="sd">        and the respective hps by concatenating X_next to X_turbo.</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_next : pytorch.tensor</span>
<span class="sd">            The most recent batch of tested hps</span>
<span class="sd">        Y_next : pytorch.tensor</span>
<span class="sd">            The most recent objective function score</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">,</span> <span class="n">X_next</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="p">,</span> <span class="n">Y_next</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_turbo_m</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the turbo_m algorithm, which is more robust than turbo_1</span>

<span class="sd">        Extended description of function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_hyper_parameters</span>
<span class="sd">            A dictionary with the best hyper-parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Remember the hypers for trust regions we don&#39;t sample from</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypers</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span><span class="p">)]</span>

        <span class="c1"># Initialize parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart_turbo_m</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1">#set up dict of turbo states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_execute_initial_parallel_batches</span><span class="p">()</span>

        
        <span class="n">n_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_samples</span>

        <span class="c1"># Run until TuRBO converges</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">RCs_per_turbo_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">turbo_batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_normal_rounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCs_per_turbo_batch</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_rounds_per_turbo_batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_normal_rounds</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_job_round_num_RCs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCs_per_turbo_batch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">turbo_iter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_normal_rounds</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_job_round_num_RCs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">turbo_iter</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">last_job_round_num_RCs</span><span class="p">]</span>

        <span class="c1">#n_trust_regions = 4</span>
        <span class="c1">#turbo_batch_size = 5</span>
        <span class="c1">#RCs_per_turbo_batch = 20</span>

        <span class="c1"># turbo_iter = [n_jobs] * n_normal_rounds</span>
        <span class="c1"># i</span>
        <span class="c1">#     turbo_iter += [last_job_round_num_RCs]</span>
        
        <span class="c1">#n_jobs = 8</span>

        <span class="c1">#[8, 8, 20-16 = 4]</span>
        
        
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_evals</span><span class="p">:</span> <span class="c1">#not self.state.restart_triggered: </span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;count: </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1">, self.n_evals </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># Generate candidates from each TR</span>
            <span class="c1">#X_cand = torch.zeros((self.n_trust_regions, self.dim), device = self.device)</span>
            <span class="c1">#y_cand = torch.inf * torch.ones((self.n_trust_regions, self.n_cand, self.batch_size), device = self.device) </span>
            <span class="n">X_nexts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">turbo_id</span><span class="p">,</span> <span class="n">round_batch_size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span><span class="p">)):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">==</span> <span class="n">turbo_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 

                <span class="n">sub_turbo_X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">sub_turbo_Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                <span class="c1"># Fit a GP model</span>
                <span class="n">train_Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">sub_turbo_Y</span> <span class="o">-</span> <span class="n">sub_turbo_Y</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="n">sub_turbo_Y</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
                <span class="n">likelihood</span> <span class="o">=</span> <span class="n">GaussianLikelihood</span><span class="p">(</span><span class="n">noise_constraint</span><span class="o">=</span><span class="n">Interval</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">))</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">SingleTaskGP</span><span class="p">(</span><span class="n">sub_turbo_X</span><span class="p">,</span> <span class="n">train_Y</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="n">likelihood</span><span class="p">)</span>
                <span class="n">mll</span> <span class="o">=</span> <span class="n">ExactMarginalLogLikelihood</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">likelihood</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
                <span class="n">fit_gpytorch_model</span><span class="p">(</span><span class="n">mll</span><span class="p">)</span>

                <span class="c1"># Create a batch</span>
                <span class="n">X_next</span> <span class="o">=</span> <span class="n">generate_batch</span><span class="p">(</span>
                    <span class="n">state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">turbo_id</span><span class="p">],</span>
                    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">sub_turbo_X</span><span class="p">,</span>
                    <span class="n">Y</span><span class="o">=</span><span class="n">train_Y</span><span class="p">,</span>
                    <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">turbo_batch_size</span><span class="p">,</span>
                    <span class="n">n_candidates</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">200</span> <span class="o">*</span> <span class="n">dim</span><span class="p">)),</span>
                    <span class="n">num_restarts</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">raw_samples</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span>
                    <span class="n">acqf</span><span class="o">=</span><span class="s2">&quot;ts&quot;</span><span class="p">,</span>
                    <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
                <span class="p">)</span>
                <span class="n">tuple_</span> <span class="o">=</span> <span class="n">X_next</span><span class="p">,</span> <span class="n">turbo_id</span><span class="p">,</span> 
                <span class="n">X_next_lst</span> <span class="o">=</span> <span class="n">X_next</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_next</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">X_next_tuple_lst</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">X_next_i</span><span class="p">,</span> <span class="n">turbo_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">X_next_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">X_next_lst</span><span class="p">)]</span>
                <span class="n">X_nexts</span> <span class="o">+=</span> <span class="n">X_next_tuple_lst</span>

            <span class="n">X_nexts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">X_nexts</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">X_nexts</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_nexts</span><span class="p">]</span>

            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_cv_samples</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parallel_trust_regions</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_trust_regions</span><span class="p">:</span>

                <span class="n">objective_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_new_turbo_batches</span><span class="p">(</span><span class="n">X_nexts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">turbo_iter</span><span class="p">)</span>

                <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">objective_input</span> <span class="ow">in</span> <span class="n">objective_inputs</span><span class="p">:</span>
                    <span class="n">result_i</span> <span class="o">=</span> <span class="n">eval_objective_remote</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parallel_args_id</span><span class="p">,</span> <span class="n">objective_input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_i</span><span class="p">)</span>

                <span class="n">X_nexts_mod</span><span class="p">,</span> <span class="n">Y_nexts</span><span class="p">,</span> <span class="n">updates_dicts</span>  <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>
                <span class="n">X_nexts_mod</span><span class="p">,</span> <span class="n">Y_nexts</span><span class="p">,</span> <span class="n">updates_dicts</span>  <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_nexts_mod</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">Y_nexts</span><span class="p">),</span> <span class="n">updates_dicts</span>

                <span class="n">trust_regions_ids_lst</span>  <span class="o">=</span> <span class="p">[</span><span class="n">dictt</span><span class="p">[</span><span class="s2">&quot;trust_region_ids&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">dictt</span> <span class="ow">in</span> <span class="n">updates_dicts</span><span class="p">]</span>

                <span class="c1">#objective_inputs = [(self._convert_params(batch[0]), batch[0], batch[1]) for i, batch in enumerate(X_init_processed_batches)]</span>

                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_updates</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">results</span><span class="p">)]</span>

                <span class="c1">#self._update_idx_parallel(results)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interactive</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_train_plot_update</span><span class="p">(</span><span class="n">pred_</span> <span class="o">=</span> <span class="n">updates_dicts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;pred&quot;</span><span class="p">],</span> <span class="n">validate_y</span> <span class="o">=</span> <span class="n">updates_dicts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">steps_displayed</span> <span class="o">=</span> <span class="n">updates_dicts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;pred&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># else:</span>
            <span class="c1">#     parameters, trust_region_id = parameters</span>
            <span class="c1">#     Y_nexts = []</span>
                
            <span class="c1">#     #the algorithm is O(n) w.r.t. cv_samples.</span>
            <span class="c1">#     for i in range(self.n_trust_regions):</span>

            <span class="c1">#         #can be parallelized:</span>
            <span class="c1">#         X_next = X_nexts[i]</span>
            <span class="c1">#         objective_input = (self._convert_params(X_next), i)</span>
            <span class="c1">#         Y_next, updates_dict = self.eval_objective(objective_input) </span>
            <span class="c1">#         self._updates(scores = Y_next, batch_dict = updates_dict)</span>
            <span class="c1">#         Y_nexts.append(Y_next)</span>
            <span class="c1">#         self._idx = torch.vstack((self._idx, i * torch.ones((self.batch_size, 1), dtype=torch.int32)))</span>

            <span class="c1">#     if self.interactive:</span>
            <span class="c1">#         self._train_plot_update(pred_ = updates_dict[0][&quot;pred&quot;], validate_y = updates_dict[0][&quot;y&quot;], steps_displayed = batch_dict[&quot;pred&quot;].shape[0])</span>
            <span class="n">X_nexts_stacked</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">X_nexts_mod</span><span class="p">)</span>

            <span class="n">Y_nexts_stacked</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">Y_nexts</span><span class="p">)</span>


            <span class="n">trust_regions_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">trust_regions_ids_lst</span><span class="p">))</span>
            <span class="c1">#trust_regions_ids = np.vstack(trust_regions_ids_lst).reshape(-1,).tolist()</span>

            <span class="n">lst_to_sort</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tr_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tr_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trust_regions_ids</span><span class="p">)]</span>

            <span class="n">mask</span><span class="p">,</span> <span class="n">tr_ids</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lst_to_sort</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

            <span class="n">X_nexts_batch</span> <span class="o">=</span> <span class="n">X_nexts_stacked</span><span class="p">[</span><span class="n">mask</span><span class="p">,:]</span>
            <span class="n">Y_nexts_batch</span> <span class="o">=</span> <span class="n">Y_nexts_stacked</span><span class="p">[</span><span class="n">mask</span><span class="p">,:]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span><span class="p">):</span>

                <span class="n">Y_next_spec</span> <span class="o">=</span> <span class="n">Y_nexts_batch</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">X_next_spec</span> <span class="o">=</span> <span class="n">X_nexts_batch</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1">#assert False, f&#39;&#39;</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">update_state</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Y_next</span><span class="o">=</span><span class="n">Y_next_spec</span><span class="p">)</span>

                <span class="c1"># Append data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_turbo</span><span class="p">(</span><span class="n">X_next</span> <span class="o">=</span> <span class="n">X_next_spec</span><span class="p">,</span> <span class="n">Y_next</span> <span class="o">=</span> <span class="n">Y_next_spec</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">Y_next_spec</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">))</span>

                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">turbo_batch_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trust_regions</span>

            <span class="c1">#check if states need to be restarted</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">restart_triggered</span><span class="p">:</span>

                    <span class="n">idx_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span>

                    <span class="c1">#remove points from trust region</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">[</span><span class="n">idx_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_errorz</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errorz_step</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length_progress</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_evals</span><span class="si">}</span><span class="s2">) TR-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> is restarting from: : ... #TODO&quot;</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_execute_initial_parallel_batch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                    <span class="c1">#X_init = get_initial_points(self.scaled_bounds.shape[1], self.initial_samples, device = self.device, dtype = self.dtype)</span>
                    
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">restart_triggered</span> <span class="o">==</span> <span class="kc">False</span>
                    
                    <span class="c1">#{fbest:.4}&quot;)</span>

                    <span class="c1">#self._errorz_step[i] += [min(self._errorz[i])] * self.batch_size</span>


            <span class="c1"># # Print current status</span>
            <span class="c1"># print( </span>
            <span class="c1">#     f&quot;{len(self.X_turbo)}) Best score: {max(Y_next).item():.4f},  TR length: {self.state.length:.2e}&quot; + </span>
            <span class="c1">#     f&quot; length {self.state.length}&quot;# Best value:.item() {state.best_value:.2e},</span>
            <span class="c1"># )</span>
            
            <span class="c1"># print( </span>
            <span class="c1">#     f&quot;TR length: {self.state.length:.2e},&quot; +  f&quot; min length {self.state.length_min:.2e}&quot;</span>
            <span class="c1">#     # + Best value:.item() {state.best_value:.2e},</span>
            <span class="c1"># )</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">display</span><span class="o">.</span><span class="n">clear_output</span><span class="p">()</span>

        
        <span class="c1">#display.clear_output(wait=True) </span>
        <span class="c1">#display.display(pl.gcf())</span>
                    
        <span class="c1"># Save to disk if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">store_path</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">best_arguments</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="n">best_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="p">)]</span>
        
        <span class="n">denormed_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denormalize_bounds</span><span class="p">(</span><span class="n">best_vals</span><span class="p">)</span>
        
        
        <span class="c1">#best_vals = X_turbo[torch.argmax(Y_turbo)]</span>

        <span class="c1">#####Bad temporary code to change it back into a dictionary</span>
        <span class="n">denormed_free_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="p">,</span> <span class="n">denormed_</span><span class="p">))</span>
        <span class="n">denormed_free_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">denormed_free_parameters</span><span class="p">])</span>

        <span class="n">best_hyper_parameters</span> <span class="o">=</span> <span class="n">denormed_free_parameters</span>
        <span class="k">for</span> <span class="n">fixed_parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_parameters</span><span class="p">:</span>
            <span class="n">best_hyper_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="n">fixed_parameter</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">fixed_parameter</span><span class="p">],</span> <span class="o">**</span><span class="n">best_hyper_parameters</span> <span class="p">}</span>

        <span class="c1">#log_vars = [&#39;connectivity&#39;, &#39;llambda&#39;, &#39;llambda2&#39;, &#39;noise&#39;, &#39;regularization&#39;, &#39;dt&#39;]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">best_hyper_parameters</span><span class="p">:</span>
                <span class="n">best_hyper_parameters</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">best_hyper_parameters</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> 


                
        <span class="c1"># Return best parameters</span>
        <span class="k">return</span> <span class="n">best_hyper_parameters</span>
        

    <span class="k">def</span> <span class="nf">_restart_turbo_m</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO doctstring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Track what trust region proposed what using an index vector</span>
        <span class="c1"># self.failcount = torch.zeros(self.n_trust_regions, dtype=torch.int32)</span>
        <span class="c1"># self.succcount = torch.zeros(self.n_trust_regions, dtype=torch.int32)</span>
        <span class="c1"># self.length = self.length_init * torch.ones(self.n_trust_regions)</span>

<div class="viewcode-block" id="RcBayesOpt.recover_hps"><a class="viewcode-back" href="../../Pages/api.html#rctorchprivate.rc_bayes.RcBayesOpt.recover_hps">[docs]</a>    <span class="k">def</span> <span class="nf">recover_hps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternative_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recover best hyper-parameters from RcBayesOpt object.</span>
<span class="sd">        </span>
<span class="sd">        This is useful if your run crashed, or you put a large number of iterations and </span>
<span class="sd">        are training the object in a jupyter notebook and you want to stop the run.</span>

<span class="sd">        This method will then recover the best hyper-parameters by extracting them from the</span>
<span class="sd">        :attr:`X_turbo` (list of hp values) and :attr:`y_turbo` (the respective scores), along with</span>
<span class="sd">        converting those HPs back to their original scale.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alternative__index: int</span>
<span class="sd">            the alternative_index will give you the i/ :sup:th best hyper-parameters (as opposed to the HPs with the highest score)</span>
<span class="sd">            this method allows you to extract them. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_hyper_parameters: dict</span>
<span class="sd">            a dictionary with the optimized hyper-parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alternative_index</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">best_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="p">))</span>
            <span class="c1">#I&#39;m too lazy to change this now but best_vals will refer to the selected hps to &quot;recover&quot;</span>
            <span class="n">best_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">[</span><span class="n">best_indices</span><span class="p">[</span><span class="n">alternative_index</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">best_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_turbo</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_turbo</span><span class="p">)]</span>
            
        <span class="n">denormed_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_denormalize_bounds</span><span class="p">(</span><span class="n">best_vals</span><span class="p">)</span>

        <span class="c1">#best_vals = X_turbo[torch.argmax(Y_turbo)]</span>

        <span class="c1">#####Bad temporary code to change it back into a dictionaryf</span>
        <span class="n">denormed_free_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_parameters</span><span class="p">,</span> <span class="n">denormed_</span><span class="p">))</span>
        <span class="n">denormed_free_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">denormed_free_parameters</span><span class="p">])</span>

        <span class="n">best_hyper_parameters</span> <span class="o">=</span> <span class="n">denormed_free_parameters</span>
        <span class="k">for</span> <span class="n">fixed_parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_parameters</span><span class="p">:</span>
            <span class="n">best_hyper_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="n">fixed_parameter</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">fixed_parameter</span><span class="p">],</span> <span class="o">**</span><span class="n">best_hyper_parameters</span> <span class="p">}</span>

        <span class="c1">#log_vars = [&#39;connectivity&#39;, &#39;llambda&#39;, &#39;llambda2&#39;, &#39;noise&#39;, &#39;regularization&#39;, &#39;dt&#39;]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">best_hyper_parameters</span><span class="p">:</span>
                <span class="n">best_hyper_parameters</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">best_hyper_parameters</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> 



        <span class="c1"># Return best parameters</span>
        <span class="k">return</span> <span class="n">best_hyper_parameters</span></div></div>

<span class="c1">#EchoStateNetworkCV = RcBayesOpt</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">RcTorch</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Pages/api.html">RcTorch API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Pages/tutorials/forced_pendulum.html">RcTorch Tutorial: Forced Pedulum Example</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Hayden Joy.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>